/* automatically generated by rust-bindgen 0.59.2 */

pub const LIBAVUTIL_VERSION_MAJOR: u32 = 56;
pub const LIBAVUTIL_VERSION_MINOR: u32 = 70;
pub const LIBAVUTIL_VERSION_MICRO: u32 = 100;
pub const LIBAVCODEC_VERSION_MAJOR: u32 = 58;
pub const LIBAVCODEC_VERSION_MINOR: u32 = 134;
pub const LIBAVCODEC_VERSION_MICRO: u32 = 100;
pub const LIBAVDEVICE_VERSION_MAJOR: u32 = 58;
pub const LIBAVDEVICE_VERSION_MINOR: u32 = 13;
pub const LIBAVDEVICE_VERSION_MICRO: u32 = 100;
pub const LIBAVFILTER_VERSION_MAJOR: u32 = 7;
pub const LIBAVFILTER_VERSION_MINOR: u32 = 110;
pub const LIBAVFILTER_VERSION_MICRO: u32 = 100;
pub const LIBAVFORMAT_VERSION_MAJOR: u32 = 58;
pub const LIBAVFORMAT_VERSION_MINOR: u32 = 76;
pub const LIBAVFORMAT_VERSION_MICRO: u32 = 100;
pub const FF_API_R_FRAME_RATE: u32 = 1;
pub const FF_LAMBDA_SHIFT: u32 = 7;
pub const FF_LAMBDA_SCALE: u32 = 128;
pub const FF_QP2LAMBDA: u32 = 118;
pub const FF_LAMBDA_MAX: u32 = 32767;
pub const FF_QUALITY_SCALE: u32 = 128;
pub const AV_TIME_BASE: u32 = 1000000;
pub const _BSD_SOURCE: u32 = 1;
pub const _XOPEN_SOURCE: u32 = 700;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const ENOTSUP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const __BYTE_ORDER: u32 = 1234;
pub const __LONG_MAX: u64 = 9223372036854775807;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __USE_TIME_BITS64: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST64_MAX: i32 = -1;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const __PRI64: &[u8; 2usize] = b"l\0";
pub const __PRIPTR: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 2usize] = b"d\0";
pub const PRIdFAST32: &[u8; 2usize] = b"d\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 2usize] = b"i\0";
pub const PRIiFAST32: &[u8; 2usize] = b"i\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 2usize] = b"o\0";
pub const PRIoFAST32: &[u8; 2usize] = b"o\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 2usize] = b"u\0";
pub const PRIuFAST32: &[u8; 2usize] = b"u\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 2usize] = b"x\0";
pub const PRIxFAST32: &[u8; 2usize] = b"x\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 2usize] = b"X\0";
pub const PRIXFAST32: &[u8; 2usize] = b"X\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"ld\0";
pub const PRIiMAX: &[u8; 3usize] = b"li\0";
pub const PRIoMAX: &[u8; 3usize] = b"lo\0";
pub const PRIuMAX: &[u8; 3usize] = b"lu\0";
pub const PRIxMAX: &[u8; 3usize] = b"lx\0";
pub const PRIXMAX: &[u8; 3usize] = b"lX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 2usize] = b"d\0";
pub const SCNdFAST32: &[u8; 2usize] = b"d\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 2usize] = b"i\0";
pub const SCNiFAST32: &[u8; 2usize] = b"i\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 2usize] = b"u\0";
pub const SCNuFAST32: &[u8; 2usize] = b"u\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 2usize] = b"o\0";
pub const SCNoFAST32: &[u8; 2usize] = b"o\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 2usize] = b"x\0";
pub const SCNxFAST32: &[u8; 2usize] = b"x\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"ld\0";
pub const SCNiMAX: &[u8; 3usize] = b"li\0";
pub const SCNoMAX: &[u8; 3usize] = b"lo\0";
pub const SCNuMAX: &[u8; 3usize] = b"lu\0";
pub const SCNxMAX: &[u8; 3usize] = b"lx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const ULONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const ULLONG_MAX: i32 = -1;
pub const MB_LEN_MAX: u32 = 4;
pub const PAGESIZE: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const FILESIZEBITS: u32 = 64;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const NGROUPS_MAX: u32 = 32;
pub const ARG_MAX: u32 = 131072;
pub const IOV_MAX: u32 = 1024;
pub const SYMLOOP_MAX: u32 = 40;
pub const WORD_BIT: u32 = 32;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const TZNAME_MAX: u32 = 6;
pub const TTY_NAME_MAX: u32 = 32;
pub const HOST_NAME_MAX: u32 = 255;
pub const LONG_BIT: u32 = 64;
pub const PTHREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_STACK_MIN: u32 = 2048;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const SEM_NSEMS_MAX: u32 = 256;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 4096;
pub const RE_DUP_MAX: u32 = 255;
pub const NL_ARGMAX: u32 = 9;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const PAGE_SIZE: u32 = 4096;
pub const NZERO: u32 = 20;
pub const NL_LANGMAX: u32 = 32;
pub const NL_NMAX: u32 = 16;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 2;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const FILENAME_MAX: u32 = 4096;
pub const FOPEN_MAX: u32 = 1000;
pub const TMP_MAX: u32 = 10000;
pub const L_tmpnam: u32 = 20;
pub const L_ctermid: u32 = 20;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const L_cuserid: u32 = 20;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const AV_HAVE_BIGENDIAN: u32 = 0;
pub const AV_HAVE_FAST_UNALIGNED: u32 = 0;
pub const AVERROR_EXPERIMENTAL: i32 = -733130664;
pub const AVERROR_INPUT_CHANGED: i32 = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: i32 = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: u32 = 64;
pub const M_LOG2_10: f64 = 3.321928094887362;
pub const M_PHI: f64 = 1.618033988749895;
pub const AV_LOG_QUIET: i32 = -8;
pub const AV_LOG_PANIC: u32 = 0;
pub const AV_LOG_FATAL: u32 = 8;
pub const AV_LOG_ERROR: u32 = 16;
pub const AV_LOG_WARNING: u32 = 24;
pub const AV_LOG_INFO: u32 = 32;
pub const AV_LOG_VERBOSE: u32 = 40;
pub const AV_LOG_DEBUG: u32 = 48;
pub const AV_LOG_TRACE: u32 = 56;
pub const AV_LOG_MAX_OFFSET: u32 = 64;
pub const AV_LOG_SKIP_REPEATED: u32 = 1;
pub const AV_LOG_PRINT_LEVEL: u32 = 2;
pub const AVPALETTE_SIZE: u32 = 1024;
pub const AVPALETTE_COUNT: u32 = 256;
pub const AV_FOURCC_MAX_STRING_SIZE: u32 = 32;
pub const LIBPOSTPROC_VERSION_MAJOR: u32 = 55;
pub const LIBPOSTPROC_VERSION_MINOR: u32 = 9;
pub const LIBPOSTPROC_VERSION_MICRO: u32 = 100;
pub const AV_CH_FRONT_LEFT: u32 = 1;
pub const AV_CH_FRONT_RIGHT: u32 = 2;
pub const AV_CH_FRONT_CENTER: u32 = 4;
pub const AV_CH_LOW_FREQUENCY: u32 = 8;
pub const AV_CH_BACK_LEFT: u32 = 16;
pub const AV_CH_BACK_RIGHT: u32 = 32;
pub const AV_CH_FRONT_LEFT_OF_CENTER: u32 = 64;
pub const AV_CH_FRONT_RIGHT_OF_CENTER: u32 = 128;
pub const AV_CH_BACK_CENTER: u32 = 256;
pub const AV_CH_SIDE_LEFT: u32 = 512;
pub const AV_CH_SIDE_RIGHT: u32 = 1024;
pub const AV_CH_TOP_CENTER: u32 = 2048;
pub const AV_CH_TOP_FRONT_LEFT: u32 = 4096;
pub const AV_CH_TOP_FRONT_CENTER: u32 = 8192;
pub const AV_CH_TOP_FRONT_RIGHT: u32 = 16384;
pub const AV_CH_TOP_BACK_LEFT: u32 = 32768;
pub const AV_CH_TOP_BACK_CENTER: u32 = 65536;
pub const AV_CH_TOP_BACK_RIGHT: u32 = 131072;
pub const AV_CH_STEREO_LEFT: u32 = 536870912;
pub const AV_CH_STEREO_RIGHT: u32 = 1073741824;
pub const AV_CH_WIDE_LEFT: u32 = 2147483648;
pub const AV_CH_WIDE_RIGHT: u64 = 4294967296;
pub const AV_CH_SURROUND_DIRECT_LEFT: u64 = 8589934592;
pub const AV_CH_SURROUND_DIRECT_RIGHT: u64 = 17179869184;
pub const AV_CH_LOW_FREQUENCY_2: u64 = 34359738368;
pub const AV_CH_TOP_SIDE_LEFT: u64 = 68719476736;
pub const AV_CH_TOP_SIDE_RIGHT: u64 = 137438953472;
pub const AV_CH_BOTTOM_FRONT_CENTER: u64 = 274877906944;
pub const AV_CH_BOTTOM_FRONT_LEFT: u64 = 549755813888;
pub const AV_CH_BOTTOM_FRONT_RIGHT: u64 = 1099511627776;
pub const AV_CH_LAYOUT_NATIVE: i64 = -9223372036854775808;
pub const AV_CH_LAYOUT_MONO: u32 = 4;
pub const AV_CH_LAYOUT_STEREO: u32 = 3;
pub const AV_CH_LAYOUT_2POINT1: u32 = 11;
pub const AV_CH_LAYOUT_2_1: u32 = 259;
pub const AV_CH_LAYOUT_SURROUND: u32 = 7;
pub const AV_CH_LAYOUT_3POINT1: u32 = 15;
pub const AV_CH_LAYOUT_4POINT0: u32 = 263;
pub const AV_CH_LAYOUT_4POINT1: u32 = 271;
pub const AV_CH_LAYOUT_2_2: u32 = 1539;
pub const AV_CH_LAYOUT_QUAD: u32 = 51;
pub const AV_CH_LAYOUT_5POINT0: u32 = 1543;
pub const AV_CH_LAYOUT_5POINT1: u32 = 1551;
pub const AV_CH_LAYOUT_5POINT0_BACK: u32 = 55;
pub const AV_CH_LAYOUT_5POINT1_BACK: u32 = 63;
pub const AV_CH_LAYOUT_6POINT0: u32 = 1799;
pub const AV_CH_LAYOUT_6POINT0_FRONT: u32 = 1731;
pub const AV_CH_LAYOUT_HEXAGONAL: u32 = 311;
pub const AV_CH_LAYOUT_6POINT1: u32 = 1807;
pub const AV_CH_LAYOUT_6POINT1_BACK: u32 = 319;
pub const AV_CH_LAYOUT_6POINT1_FRONT: u32 = 1739;
pub const AV_CH_LAYOUT_7POINT0: u32 = 1591;
pub const AV_CH_LAYOUT_7POINT0_FRONT: u32 = 1735;
pub const AV_CH_LAYOUT_7POINT1: u32 = 1599;
pub const AV_CH_LAYOUT_7POINT1_WIDE: u32 = 1743;
pub const AV_CH_LAYOUT_7POINT1_WIDE_BACK: u32 = 255;
pub const AV_CH_LAYOUT_OCTAGONAL: u32 = 1847;
pub const AV_CH_LAYOUT_HEXADECAGONAL: u64 = 6442710839;
pub const AV_CH_LAYOUT_STEREO_DOWNMIX: u32 = 1610612736;
pub const AV_CH_LAYOUT_22POINT2: u64 = 2164663779327;
pub const AV_BUFFER_FLAG_READONLY: u32 = 1;
pub const AV_DICT_MATCH_CASE: u32 = 1;
pub const AV_DICT_IGNORE_SUFFIX: u32 = 2;
pub const AV_DICT_DONT_STRDUP_KEY: u32 = 4;
pub const AV_DICT_DONT_STRDUP_VAL: u32 = 8;
pub const AV_DICT_DONT_OVERWRITE: u32 = 16;
pub const AV_DICT_APPEND: u32 = 32;
pub const AV_DICT_MULTIKEY: u32 = 64;
pub const AV_NUM_DATA_POINTERS: u32 = 8;
pub const AV_FRAME_FLAG_CORRUPT: u32 = 1;
pub const AV_FRAME_FLAG_DISCARD: u32 = 4;
pub const FF_DECODE_ERROR_INVALID_BITSTREAM: u32 = 1;
pub const FF_DECODE_ERROR_MISSING_REFERENCE: u32 = 2;
pub const FF_DECODE_ERROR_CONCEALMENT_ACTIVE: u32 = 4;
pub const FF_DECODE_ERROR_DECODE_SLICES: u32 = 8;
pub const LIBSWRESAMPLE_VERSION_MAJOR: u32 = 3;
pub const LIBSWRESAMPLE_VERSION_MINOR: u32 = 9;
pub const LIBSWRESAMPLE_VERSION_MICRO: u32 = 100;
pub const SWR_FLAG_RESAMPLE: u32 = 1;
pub const LIBSWSCALE_VERSION_MAJOR: u32 = 5;
pub const LIBSWSCALE_VERSION_MINOR: u32 = 9;
pub const LIBSWSCALE_VERSION_MICRO: u32 = 100;
extern "C" {
  #[doc = " Return the LIBAVUTIL_VERSION_INT constant."]
  pub fn avutil_version() -> ::std::os::raw::c_uint;
}
extern "C" {
  #[doc = " Return an informative version string. This usually is the actual release"]
  #[doc = " version number or a git commit description. This string has no fixed format"]
  #[doc = " and can change any time. It should never be parsed by code."]
  pub fn av_version_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Return the libavutil build-time configuration."]
  pub fn avutil_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Return the libavutil license."]
  pub fn avutil_license() -> *const ::std::os::raw::c_char;
}
#[doc = "< Usually treated as AVMEDIA_TYPE_DATA"]
pub const AVMediaType_AVMEDIA_TYPE_UNKNOWN: AVMediaType = -1;
pub const AVMediaType_AVMEDIA_TYPE_VIDEO: AVMediaType = 0;
pub const AVMediaType_AVMEDIA_TYPE_AUDIO: AVMediaType = 1;
#[doc = "< Opaque data information usually continuous"]
pub const AVMediaType_AVMEDIA_TYPE_DATA: AVMediaType = 2;
pub const AVMediaType_AVMEDIA_TYPE_SUBTITLE: AVMediaType = 3;
#[doc = "< Opaque data information usually sparse"]
pub const AVMediaType_AVMEDIA_TYPE_ATTACHMENT: AVMediaType = 4;
pub const AVMediaType_AVMEDIA_TYPE_NB: AVMediaType = 5;
#[doc = " @addtogroup lavu_media Media Type"]
#[doc = " @brief Media Type"]
pub type AVMediaType = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Return a string describing the media_type enum, NULL if media_type"]
  #[doc = " is unknown."]
  pub fn av_get_media_type_string(media_type: AVMediaType) -> *const ::std::os::raw::c_char;
}
#[doc = "< Undefined"]
pub const AVPictureType_AV_PICTURE_TYPE_NONE: AVPictureType = 0;
#[doc = "< Intra"]
pub const AVPictureType_AV_PICTURE_TYPE_I: AVPictureType = 1;
#[doc = "< Predicted"]
pub const AVPictureType_AV_PICTURE_TYPE_P: AVPictureType = 2;
#[doc = "< Bi-dir predicted"]
pub const AVPictureType_AV_PICTURE_TYPE_B: AVPictureType = 3;
#[doc = "< S(GMC)-VOP MPEG-4"]
pub const AVPictureType_AV_PICTURE_TYPE_S: AVPictureType = 4;
#[doc = "< Switching Intra"]
pub const AVPictureType_AV_PICTURE_TYPE_SI: AVPictureType = 5;
#[doc = "< Switching Predicted"]
pub const AVPictureType_AV_PICTURE_TYPE_SP: AVPictureType = 6;
#[doc = "< BI type"]
pub const AVPictureType_AV_PICTURE_TYPE_BI: AVPictureType = 7;
#[doc = " @}"]
#[doc = " @}"]
#[doc = " @defgroup lavu_picture Image related"]
#[doc = ""]
#[doc = " AVPicture types, pixel formats and basic image planes manipulation."]
#[doc = ""]
#[doc = " @{"]
pub type AVPictureType = ::std::os::raw::c_uint;
extern "C" {
  #[doc = " Return a single letter to describe the given picture type"]
  #[doc = " pict_type."]
  #[doc = ""]
  #[doc = " @param[in] pict_type the picture type @return a single character"]
  #[doc = " representing the picture type, '?' if pict_type is unknown"]
  pub fn av_get_picture_type_char(pict_type: AVPictureType) -> ::std::os::raw::c_char;
}
extern "C" {
  pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = i8;
pub type int_fast64_t = i64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast64_t = u64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast16_t = i32;
pub type int_fast32_t = i32;
pub type uint_fast16_t = u32;
pub type uint_fast32_t = u32;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
  pub quot: intmax_t,
  pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
  assert_eq!(
    ::std::mem::size_of::<imaxdiv_t>(),
    16usize,
    concat!("Size of: ", stringify!(imaxdiv_t))
  );
  assert_eq!(
    ::std::mem::align_of::<imaxdiv_t>(),
    8usize,
    concat!("Alignment of ", stringify!(imaxdiv_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(imaxdiv_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(imaxdiv_t),
      "::",
      stringify!(rem)
    )
  );
}
extern "C" {
  pub fn imaxabs(arg1: intmax_t) -> intmax_t;
}
extern "C" {
  pub fn imaxdiv(arg1: intmax_t, arg2: intmax_t) -> imaxdiv_t;
}
extern "C" {
  pub fn strtoimax(
    arg1: *const ::std::os::raw::c_char,
    arg2: *mut *mut ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
  ) -> intmax_t;
}
extern "C" {
  pub fn strtoumax(
    arg1: *const ::std::os::raw::c_char,
    arg2: *mut *mut ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
  ) -> uintmax_t;
}
extern "C" {
  pub fn wcstoimax(
    arg1: *const wchar_t,
    arg2: *mut *mut wchar_t,
    arg3: ::std::os::raw::c_int,
  ) -> intmax_t;
}
extern "C" {
  pub fn wcstoumax(
    arg1: *const wchar_t,
    arg2: *mut *mut wchar_t,
    arg3: ::std::os::raw::c_int,
  ) -> uintmax_t;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
  pub fn __fpclassify(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __fpclassifyl(arg1: u128) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __signbit(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __signbitf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __signbitl(arg1: u128) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn acos(arg1: f64) -> f64;
}
extern "C" {
  pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
  pub fn acosl(arg1: u128) -> u128;
}
extern "C" {
  pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
  pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
  pub fn acoshl(arg1: u128) -> u128;
}
extern "C" {
  pub fn asin(arg1: f64) -> f64;
}
extern "C" {
  pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
  pub fn asinl(arg1: u128) -> u128;
}
extern "C" {
  pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
  pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
  pub fn asinhl(arg1: u128) -> u128;
}
extern "C" {
  pub fn atan(arg1: f64) -> f64;
}
extern "C" {
  pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
  pub fn atanl(arg1: u128) -> u128;
}
extern "C" {
  pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  pub fn atan2l(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
  pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
  pub fn atanhl(arg1: u128) -> u128;
}
extern "C" {
  pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
  pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
  pub fn cbrtl(arg1: u128) -> u128;
}
extern "C" {
  pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
  pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
  pub fn ceill(arg1: u128) -> u128;
}
extern "C" {
  pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  pub fn copysignl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  pub fn cos(arg1: f64) -> f64;
}
extern "C" {
  pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
  pub fn cosl(arg1: u128) -> u128;
}
extern "C" {
  pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
  pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
  pub fn coshl(arg1: u128) -> u128;
}
extern "C" {
  pub fn erf(arg1: f64) -> f64;
}
extern "C" {
  pub fn erff(arg1: f32) -> f32;
}
extern "C" {
  pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
  pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
  pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
  pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
  pub fn exp(arg1: f64) -> f64;
}
extern "C" {
  pub fn expf(arg1: f32) -> f32;
}
extern "C" {
  pub fn expl(arg1: u128) -> u128;
}
extern "C" {
  pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
  pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
  pub fn exp2l(arg1: u128) -> u128;
}
extern "C" {
  pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
  pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
  pub fn expm1l(arg1: u128) -> u128;
}
extern "C" {
  pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
  pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
  pub fn fabsl(arg1: u128) -> u128;
}
extern "C" {
  pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  pub fn fdiml(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  pub fn floor(arg1: f64) -> f64;
}
extern "C" {
  pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
  pub fn floorl(arg1: u128) -> u128;
}
extern "C" {
  pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
  pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
  pub fn fmal(arg1: u128, arg2: u128, arg3: u128) -> u128;
}
extern "C" {
  pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  pub fn fmaxl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  pub fn fminl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  pub fn fmodl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
  pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
  pub fn frexpl(arg1: u128, arg2: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
  pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  pub fn hypotl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ilogbl(arg1: u128) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
  pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
  pub fn ldexpl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
extern "C" {
  pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
  pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
  pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
  pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn llrintl(arg1: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn llroundl(arg1: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn log(arg1: f64) -> f64;
}
extern "C" {
  pub fn logf(arg1: f32) -> f32;
}
extern "C" {
  pub fn logl(arg1: u128) -> u128;
}
extern "C" {
  pub fn log10(arg1: f64) -> f64;
}
extern "C" {
  pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
  pub fn log10l(arg1: u128) -> u128;
}
extern "C" {
  pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
  pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
  pub fn log1pl(arg1: u128) -> u128;
}
extern "C" {
  pub fn log2(arg1: f64) -> f64;
}
extern "C" {
  pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
  pub fn log2l(arg1: u128) -> u128;
}
extern "C" {
  pub fn logb(arg1: f64) -> f64;
}
extern "C" {
  pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
  pub fn logbl(arg1: u128) -> u128;
}
extern "C" {
  pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn lrintl(arg1: u128) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn lroundl(arg1: u128) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
  pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
  pub fn modfl(arg1: u128, arg2: *mut u128) -> u128;
}
extern "C" {
  pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
  pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
  pub fn nanl(arg1: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
  pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
  pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
  pub fn nearbyintl(arg1: u128) -> u128;
}
extern "C" {
  pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  pub fn nextafterl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  pub fn nexttoward(arg1: f64, arg2: u128) -> f64;
}
extern "C" {
  pub fn nexttowardf(arg1: f32, arg2: u128) -> f32;
}
extern "C" {
  pub fn nexttowardl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  pub fn powl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  pub fn remainderl(arg1: u128, arg2: u128) -> u128;
}
extern "C" {
  pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
  pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
  pub fn remquol(arg1: u128, arg2: u128, arg3: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
  pub fn rint(arg1: f64) -> f64;
}
extern "C" {
  pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
  pub fn rintl(arg1: u128) -> u128;
}
extern "C" {
  pub fn round(arg1: f64) -> f64;
}
extern "C" {
  pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
  pub fn roundl(arg1: u128) -> u128;
}
extern "C" {
  pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
  pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
  pub fn scalblnl(arg1: u128, arg2: ::std::os::raw::c_long) -> u128;
}
extern "C" {
  pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
  pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
  pub fn scalbnl(arg1: u128, arg2: ::std::os::raw::c_int) -> u128;
}
extern "C" {
  pub fn sin(arg1: f64) -> f64;
}
extern "C" {
  pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
  pub fn sinl(arg1: u128) -> u128;
}
extern "C" {
  pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
  pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
  pub fn sinhl(arg1: u128) -> u128;
}
extern "C" {
  pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
  pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
  pub fn sqrtl(arg1: u128) -> u128;
}
extern "C" {
  pub fn tan(arg1: f64) -> f64;
}
extern "C" {
  pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
  pub fn tanl(arg1: u128) -> u128;
}
extern "C" {
  pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
  pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
  pub fn tanhl(arg1: u128) -> u128;
}
extern "C" {
  pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
  pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
  pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
  pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
  pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
  pub fn truncl(arg1: u128) -> u128;
}
extern "C" {
  pub static mut signgam: ::std::os::raw::c_int;
}
extern "C" {
  pub fn j0(arg1: f64) -> f64;
}
extern "C" {
  pub fn j1(arg1: f64) -> f64;
}
extern "C" {
  pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
  pub fn y0(arg1: f64) -> f64;
}
extern "C" {
  pub fn y1(arg1: f64) -> f64;
}
extern "C" {
  pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
  pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  pub fn dremf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  pub fn finite(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn finitef(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
  pub fn scalbf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
  pub fn significand(arg1: f64) -> f64;
}
extern "C" {
  pub fn significandf(arg1: f32) -> f32;
}
extern "C" {
  pub fn lgamma_r(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
  pub fn lgammaf_r(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
  pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
  pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
  pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
  pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
  pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
  pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
pub type size_t = ::std::os::raw::c_ulong;
pub type ssize_t = ::std::os::raw::c_long;
pub type off_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
  _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
pub type va_list = __builtin_va_list;
pub type __isoc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _G_fpos64_t {
  pub __opaque: [::std::os::raw::c_char; 16usize],
  pub __lldata: ::std::os::raw::c_longlong,
  pub __align: f64,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
  assert_eq!(
    ::std::mem::size_of::<_G_fpos64_t>(),
    16usize,
    concat!("Size of: ", stringify!(_G_fpos64_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_G_fpos64_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_G_fpos64_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__opaque as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_G_fpos64_t),
      "::",
      stringify!(__opaque)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__lldata as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_G_fpos64_t),
      "::",
      stringify!(__lldata)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__align as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_G_fpos64_t),
      "::",
      stringify!(__align)
    )
  );
}
pub type fpos_t = _G_fpos64_t;
extern "C" {
  pub static stdin: *mut FILE;
}
extern "C" {
  pub static stdout: *mut FILE;
}
extern "C" {
  pub static stderr: *mut FILE;
}
extern "C" {
  pub fn fopen(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
extern "C" {
  pub fn freopen(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut FILE,
  ) -> *mut FILE;
}
extern "C" {
  pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn rename(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
  pub fn fseek(
    arg1: *mut FILE,
    arg2: ::std::os::raw::c_long,
    arg3: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn rewind(arg1: *mut FILE);
}
extern "C" {
  pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fread(
    arg1: *mut ::std::os::raw::c_void,
    arg2: ::std::os::raw::c_ulong,
    arg3: ::std::os::raw::c_ulong,
    arg4: *mut FILE,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn fwrite(
    arg1: *const ::std::os::raw::c_void,
    arg2: ::std::os::raw::c_ulong,
    arg3: ::std::os::raw::c_ulong,
    arg4: *mut FILE,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fgets(
    arg1: *mut ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
    arg3: *mut FILE,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fprintf(
    arg1: *mut FILE,
    arg2: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn sprintf(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn snprintf(
    arg1: *mut ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_ulong,
    arg3: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vprintf(
    arg1: *const ::std::os::raw::c_char,
    arg2: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vfprintf(
    arg1: *mut FILE,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vsprintf(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vsnprintf(
    arg1: *mut ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_ulong,
    arg3: *const ::std::os::raw::c_char,
    arg4: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
    -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn sscanf(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vscanf(
    arg1: *const ::std::os::raw::c_char,
    arg2: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vfscanf(
    arg1: *mut FILE,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vsscanf(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
  pub fn setvbuf(
    arg1: *mut FILE,
    arg2: *mut ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: size_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
  pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn tmpfile() -> *mut FILE;
}
extern "C" {
  pub fn fmemopen(
    arg1: *mut ::std::os::raw::c_void,
    arg2: size_t,
    arg3: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
extern "C" {
  pub fn open_memstream(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut size_t) -> *mut FILE;
}
extern "C" {
  pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
  pub fn popen(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
extern "C" {
  pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
  pub fn dprintf(
    arg1: ::std::os::raw::c_int,
    arg2: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vdprintf(
    arg1: ::std::os::raw::c_int,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
  pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
  pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getdelim(
    arg1: *mut *mut ::std::os::raw::c_char,
    arg2: *mut size_t,
    arg3: ::std::os::raw::c_int,
    arg4: *mut FILE,
  ) -> ssize_t;
}
extern "C" {
  pub fn getline(
    arg1: *mut *mut ::std::os::raw::c_char,
    arg2: *mut size_t,
    arg3: *mut FILE,
  ) -> ssize_t;
}
extern "C" {
  pub fn renameat(
    arg1: ::std::os::raw::c_int,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
    arg4: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn tempnam(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn cuserid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn setlinebuf(arg1: *mut FILE);
}
extern "C" {
  pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char, arg3: size_t);
}
extern "C" {
  pub fn fgetc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fputc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fflush_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fread_unlocked(
    arg1: *mut ::std::os::raw::c_void,
    arg2: size_t,
    arg3: size_t,
    arg4: *mut FILE,
  ) -> size_t;
}
extern "C" {
  pub fn fwrite_unlocked(
    arg1: *const ::std::os::raw::c_void,
    arg2: size_t,
    arg3: size_t,
    arg4: *mut FILE,
  ) -> size_t;
}
extern "C" {
  pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
  pub fn feof_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ferror_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fileno_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fgetln(arg1: *mut FILE, arg2: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn asprintf(
    arg1: *mut *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vasprintf(
    arg1: *mut *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
  pub fn strtof(arg1: *const ::std::os::raw::c_char, arg2: *mut *mut ::std::os::raw::c_char)
    -> f32;
}
extern "C" {
  pub fn strtod(arg1: *const ::std::os::raw::c_char, arg2: *mut *mut ::std::os::raw::c_char)
    -> f64;
}
extern "C" {
  pub fn strtold(
    arg1: *const ::std::os::raw::c_char,
    arg2: *mut *mut ::std::os::raw::c_char,
  ) -> u128;
}
extern "C" {
  pub fn strtol(
    arg1: *const ::std::os::raw::c_char,
    arg2: *mut *mut ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn strtoul(
    arg1: *const ::std::os::raw::c_char,
    arg2: *mut *mut ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strtoll(
    arg1: *const ::std::os::raw::c_char,
    arg2: *mut *mut ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn strtoull(
    arg1: *const ::std::os::raw::c_char,
    arg2: *mut *mut ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
  pub fn malloc(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn calloc(
    arg1: ::std::os::raw::c_ulong,
    arg2: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn realloc(
    arg1: *mut ::std::os::raw::c_void,
    arg2: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn aligned_alloc(
    arg1: ::std::os::raw::c_ulong,
    arg2: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn abort();
}
extern "C" {
  pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
  pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
  pub fn at_quick_exit(
    arg1: ::std::option::Option<unsafe extern "C" fn()>,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn quick_exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
  pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn bsearch(
    arg1: *const ::std::os::raw::c_void,
    arg2: *const ::std::os::raw::c_void,
    arg3: size_t,
    arg4: size_t,
    arg5: ::std::option::Option<
      unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
      ) -> ::std::os::raw::c_int,
    >,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn qsort(
    arg1: *mut ::std::os::raw::c_void,
    arg2: size_t,
    arg3: size_t,
    arg4: ::std::option::Option<
      unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
      ) -> ::std::os::raw::c_int,
    >,
  );
}
extern "C" {
  pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
  pub quot: ::std::os::raw::c_int,
  pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
  assert_eq!(
    ::std::mem::size_of::<div_t>(),
    8usize,
    concat!("Size of: ", stringify!(div_t))
  );
  assert_eq!(
    ::std::mem::align_of::<div_t>(),
    4usize,
    concat!("Alignment of ", stringify!(div_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(div_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(div_t),
      "::",
      stringify!(rem)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
  pub quot: ::std::os::raw::c_long,
  pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
  assert_eq!(
    ::std::mem::size_of::<ldiv_t>(),
    16usize,
    concat!("Size of: ", stringify!(ldiv_t))
  );
  assert_eq!(
    ::std::mem::align_of::<ldiv_t>(),
    8usize,
    concat!("Alignment of ", stringify!(ldiv_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(ldiv_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(ldiv_t),
      "::",
      stringify!(rem)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
  pub quot: ::std::os::raw::c_longlong,
  pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
  assert_eq!(
    ::std::mem::size_of::<lldiv_t>(),
    16usize,
    concat!("Size of: ", stringify!(lldiv_t))
  );
  assert_eq!(
    ::std::mem::align_of::<lldiv_t>(),
    8usize,
    concat!("Alignment of ", stringify!(lldiv_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(lldiv_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(lldiv_t),
      "::",
      stringify!(rem)
    )
  );
}
extern "C" {
  pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
  pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
  pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
  pub fn mblen(arg1: *const ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mbtowc(
    arg1: *mut wchar_t,
    arg2: *const ::std::os::raw::c_char,
    arg3: size_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: size_t) -> size_t;
}
extern "C" {
  pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: size_t) -> size_t;
}
extern "C" {
  pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
  pub fn posix_memalign(
    arg1: *mut *mut ::std::os::raw::c_void,
    arg2: size_t,
    arg3: size_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn setenv(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mkostemp(
    arg1: *mut ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn getsubopt(
    arg1: *mut *mut ::std::os::raw::c_char,
    arg2: *const *mut ::std::os::raw::c_char,
    arg3: *mut *mut ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn realpath(
    arg1: *const ::std::os::raw::c_char,
    arg2: *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
  pub fn initstate(
    arg1: ::std::os::raw::c_uint,
    arg2: *mut ::std::os::raw::c_char,
    arg3: size_t,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn setstate(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
  pub fn drand48() -> f64;
}
extern "C" {
  pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
  pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
  pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
  pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
  pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn mkstemps(
    arg1: *mut ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mkostemps(
    arg1: *mut ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn valloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn memalign(
    arg1: ::std::os::raw::c_ulong,
    arg2: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn reallocarray(
    arg1: *mut ::std::os::raw::c_void,
    arg2: size_t,
    arg3: size_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn qsort_r(
    arg1: *mut ::std::os::raw::c_void,
    arg2: size_t,
    arg3: size_t,
    arg4: ::std::option::Option<
      unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
      ) -> ::std::os::raw::c_int,
    >,
    arg5: *mut ::std::os::raw::c_void,
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
  _unused: [u8; 0],
}
pub type locale_t = *mut __locale_struct;
extern "C" {
  pub fn memcpy(
    arg1: *mut ::std::os::raw::c_void,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn memmove(
    arg1: *mut ::std::os::raw::c_void,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn memset(
    arg1: *mut ::std::os::raw::c_void,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn memcmp(
    arg1: *const ::std::os::raw::c_void,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn memchr(
    arg1: *const ::std::os::raw::c_void,
    arg2: ::std::os::raw::c_int,
    arg3: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn strcpy(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strncpy(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strcat(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strncat(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strcmp(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strncmp(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strcoll(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strxfrm(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strchr(
    arg1: *const ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strrchr(
    arg1: *const ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strcspn(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strspn(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strpbrk(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strstr(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strtok(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strlen(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strerror(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn bcmp(
    arg1: *const ::std::os::raw::c_void,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn bcopy(
    arg1: *const ::std::os::raw::c_void,
    arg2: *mut ::std::os::raw::c_void,
    arg3: size_t,
  );
}
extern "C" {
  pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
  pub fn index(
    arg1: *const ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn rindex(
    arg1: *const ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strcasecmp(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strncasecmp(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strcasecmp_l(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: locale_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strncasecmp_l(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: size_t,
    arg4: locale_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strtok_r(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strerror_r(
    arg1: ::std::os::raw::c_int,
    arg2: *mut ::std::os::raw::c_char,
    arg3: size_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn stpcpy(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn stpncpy(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: size_t) -> size_t;
}
extern "C" {
  pub fn strdup(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strndup(
    arg1: *const ::std::os::raw::c_char,
    arg2: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strsignal(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strerror_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strcoll_l(
    arg1: *const ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: locale_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn strxfrm_l(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: size_t,
    arg4: locale_t,
  ) -> size_t;
}
extern "C" {
  pub fn memccpy(
    arg1: *mut ::std::os::raw::c_void,
    arg2: *const ::std::os::raw::c_void,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn strsep(
    arg1: *mut *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn strlcat(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strlcpy(
    arg1: *mut ::std::os::raw::c_char,
    arg2: *const ::std::os::raw::c_char,
    arg3: ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn explicit_bzero(arg1: *mut ::std::os::raw::c_void, arg2: size_t);
}
extern "C" {
  pub fn av_log2(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn av_log2_16bit(v: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
  pub __ll: ::std::os::raw::c_longlong,
  pub __bindgen_padding_0: u64,
  pub __ld: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
  assert_eq!(
    ::std::mem::size_of::<max_align_t>(),
    32usize,
    concat!("Size of: ", stringify!(max_align_t))
  );
  assert_eq!(
    ::std::mem::align_of::<max_align_t>(),
    16usize,
    concat!("Alignment of ", stringify!(max_align_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<max_align_t>())).__ll as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(max_align_t),
      "::",
      stringify!(__ll)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<max_align_t>())).__ld as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(max_align_t),
      "::",
      stringify!(__ld)
    )
  );
}
extern "C" {
  #[doc = " Put a description of the AVERROR code errnum in errbuf."]
  #[doc = " In case of failure the global variable errno is set to indicate the"]
  #[doc = " error. Even in case of failure av_strerror() will print a generic"]
  #[doc = " error message indicating the errnum provided to errbuf."]
  #[doc = ""]
  #[doc = " @param errnum      error code to describe"]
  #[doc = " @param errbuf      buffer to which description is written"]
  #[doc = " @param errbuf_size the size in bytes of errbuf"]
  #[doc = " @return 0 on success, a negative value if a description for errnum"]
  #[doc = " cannot be found"]
  pub fn av_strerror(
    errnum: ::std::os::raw::c_int,
    errbuf: *mut ::std::os::raw::c_char,
    errbuf_size: size_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Allocate a memory block with alignment suitable for all memory accesses"]
  #[doc = " (including vectors if available on the CPU)."]
  #[doc = ""]
  #[doc = " @param size Size in bytes for the memory block to be allocated"]
  #[doc = " @return Pointer to the allocated block, or `NULL` if the block cannot"]
  #[doc = "         be allocated"]
  #[doc = " @see av_mallocz()"]
  pub fn av_malloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  #[doc = " Allocate a memory block with alignment suitable for all memory accesses"]
  #[doc = " (including vectors if available on the CPU) and zero all the bytes of the"]
  #[doc = " block."]
  #[doc = ""]
  #[doc = " @param size Size in bytes for the memory block to be allocated"]
  #[doc = " @return Pointer to the allocated block, or `NULL` if it cannot be allocated"]
  #[doc = " @see av_malloc()"]
  pub fn av_mallocz(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  #[doc = " Allocate a memory block for an array with av_malloc()."]
  #[doc = ""]
  #[doc = " The allocated memory will have size `size * nmemb` bytes."]
  #[doc = ""]
  #[doc = " @param nmemb Number of element"]
  #[doc = " @param size  Size of a single element"]
  #[doc = " @return Pointer to the allocated block, or `NULL` if the block cannot"]
  #[doc = "         be allocated"]
  #[doc = " @see av_malloc()"]
  pub fn av_malloc_array(nmemb: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  #[doc = " Allocate a memory block for an array with av_mallocz()."]
  #[doc = ""]
  #[doc = " The allocated memory will have size `size * nmemb` bytes."]
  #[doc = ""]
  #[doc = " @param nmemb Number of elements"]
  #[doc = " @param size  Size of the single element"]
  #[doc = " @return Pointer to the allocated block, or `NULL` if the block cannot"]
  #[doc = "         be allocated"]
  #[doc = ""]
  #[doc = " @see av_mallocz()"]
  #[doc = " @see av_malloc_array()"]
  pub fn av_mallocz_array(nmemb: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  #[doc = " Non-inlined equivalent of av_mallocz_array()."]
  #[doc = ""]
  #[doc = " Created for symmetry with the calloc() C function."]
  pub fn av_calloc(nmemb: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  #[doc = " Allocate, reallocate, or free a block of memory."]
  #[doc = ""]
  #[doc = " If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is"]
  #[doc = " zero, free the memory block pointed to by `ptr`. Otherwise, expand or"]
  #[doc = " shrink that block of memory according to `size`."]
  #[doc = ""]
  #[doc = " @param ptr  Pointer to a memory block already allocated with"]
  #[doc = "             av_realloc() or `NULL`"]
  #[doc = " @param size Size in bytes of the memory block to be allocated or"]
  #[doc = "             reallocated"]
  #[doc = ""]
  #[doc = " @return Pointer to a newly-reallocated block or `NULL` if the block"]
  #[doc = "         cannot be reallocated or the function is used to free the memory block"]
  #[doc = ""]
  #[doc = " @warning Unlike av_malloc(), the returned pointer is not guaranteed to be"]
  #[doc = "          correctly aligned."]
  #[doc = " @see av_fast_realloc()"]
  #[doc = " @see av_reallocp()"]
  pub fn av_realloc(ptr: *mut ::std::os::raw::c_void, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  #[doc = " Allocate, reallocate, or free a block of memory through a pointer to a"]
  #[doc = " pointer."]
  #[doc = ""]
  #[doc = " If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is"]
  #[doc = " zero, free the memory block pointed to by `*ptr`. Otherwise, expand or"]
  #[doc = " shrink that block of memory according to `size`."]
  #[doc = ""]
  #[doc = " @param[in,out] ptr  Pointer to a pointer to a memory block already allocated"]
  #[doc = "                     with av_realloc(), or a pointer to `NULL`. The pointer"]
  #[doc = "                     is updated on success, or freed on failure."]
  #[doc = " @param[in]     size Size in bytes for the memory block to be allocated or"]
  #[doc = "                     reallocated"]
  #[doc = ""]
  #[doc = " @return Zero on success, an AVERROR error code on failure"]
  #[doc = ""]
  #[doc = " @warning Unlike av_malloc(), the allocated memory is not guaranteed to be"]
  #[doc = "          correctly aligned."]
  pub fn av_reallocp(ptr: *mut ::std::os::raw::c_void, size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Allocate, reallocate, or free a block of memory."]
  #[doc = ""]
  #[doc = " This function does the same thing as av_realloc(), except:"]
  #[doc = " - It takes two size arguments and allocates `nelem * elsize` bytes,"]
  #[doc = "   after checking the result of the multiplication for integer overflow."]
  #[doc = " - It frees the input block in case of failure, thus avoiding the memory"]
  #[doc = "   leak with the classic"]
  #[doc = "   @code{.c}"]
  #[doc = "   buf = realloc(buf);"]
  #[doc = "   if (!buf)"]
  #[doc = "       return -1;"]
  #[doc = "   @endcode"]
  #[doc = "   pattern."]
  pub fn av_realloc_f(
    ptr: *mut ::std::os::raw::c_void,
    nelem: size_t,
    elsize: size_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  #[doc = " Allocate, reallocate, or free an array."]
  #[doc = ""]
  #[doc = " If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If"]
  #[doc = " `nmemb` is zero, free the memory block pointed to by `ptr`."]
  #[doc = ""]
  #[doc = " @param ptr   Pointer to a memory block already allocated with"]
  #[doc = "              av_realloc() or `NULL`"]
  #[doc = " @param nmemb Number of elements in the array"]
  #[doc = " @param size  Size of the single element of the array"]
  #[doc = ""]
  #[doc = " @return Pointer to a newly-reallocated block or NULL if the block"]
  #[doc = "         cannot be reallocated or the function is used to free the memory block"]
  #[doc = ""]
  #[doc = " @warning Unlike av_malloc(), the allocated memory is not guaranteed to be"]
  #[doc = "          correctly aligned."]
  #[doc = " @see av_reallocp_array()"]
  pub fn av_realloc_array(
    ptr: *mut ::std::os::raw::c_void,
    nmemb: size_t,
    size: size_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  #[doc = " Allocate, reallocate, or free an array through a pointer to a pointer."]
  #[doc = ""]
  #[doc = " If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is"]
  #[doc = " zero, free the memory block pointed to by `*ptr`."]
  #[doc = ""]
  #[doc = " @param[in,out] ptr   Pointer to a pointer to a memory block already"]
  #[doc = "                      allocated with av_realloc(), or a pointer to `NULL`."]
  #[doc = "                      The pointer is updated on success, or freed on failure."]
  #[doc = " @param[in]     nmemb Number of elements"]
  #[doc = " @param[in]     size  Size of the single element"]
  #[doc = ""]
  #[doc = " @return Zero on success, an AVERROR error code on failure"]
  #[doc = ""]
  #[doc = " @warning Unlike av_malloc(), the allocated memory is not guaranteed to be"]
  #[doc = "          correctly aligned."]
  pub fn av_reallocp_array(
    ptr: *mut ::std::os::raw::c_void,
    nmemb: size_t,
    size: size_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Reallocate the given buffer if it is not large enough, otherwise do nothing."]
  #[doc = ""]
  #[doc = " If the given buffer is `NULL`, then a new uninitialized buffer is allocated."]
  #[doc = ""]
  #[doc = " If the given buffer is not large enough, and reallocation fails, `NULL` is"]
  #[doc = " returned and `*size` is set to 0, but the original buffer is not changed or"]
  #[doc = " freed."]
  #[doc = ""]
  #[doc = " A typical use pattern follows:"]
  #[doc = ""]
  #[doc = " @code{.c}"]
  #[doc = " uint8_t *buf = ...;"]
  #[doc = " uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);"]
  #[doc = " if (!new_buf) {"]
  #[doc = "     // Allocation failed; clean up original buffer"]
  #[doc = "     av_freep(&buf);"]
  #[doc = "     return AVERROR(ENOMEM);"]
  #[doc = " }"]
  #[doc = " @endcode"]
  #[doc = ""]
  #[doc = " @param[in,out] ptr      Already allocated buffer, or `NULL`"]
  #[doc = " @param[in,out] size     Pointer to the size of buffer `ptr`. `*size` is"]
  #[doc = "                         updated to the new allocated size, in particular 0"]
  #[doc = "                         in case of failure."]
  #[doc = " @param[in]     min_size Desired minimal size of buffer `ptr`"]
  #[doc = " @return `ptr` if the buffer is large enough, a pointer to newly reallocated"]
  #[doc = "         buffer if the buffer was not large enough, or `NULL` in case of"]
  #[doc = "         error"]
  #[doc = " @see av_realloc()"]
  #[doc = " @see av_fast_malloc()"]
  pub fn av_fast_realloc(
    ptr: *mut ::std::os::raw::c_void,
    size: *mut ::std::os::raw::c_uint,
    min_size: size_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  #[doc = " Allocate a buffer, reusing the given one if large enough."]
  #[doc = ""]
  #[doc = " Contrary to av_fast_realloc(), the current buffer contents might not be"]
  #[doc = " preserved and on error the old buffer is freed, thus no special handling to"]
  #[doc = " avoid memleaks is necessary."]
  #[doc = ""]
  #[doc = " `*ptr` is allowed to be `NULL`, in which case allocation always happens if"]
  #[doc = " `size_needed` is greater than 0."]
  #[doc = ""]
  #[doc = " @code{.c}"]
  #[doc = " uint8_t *buf = ...;"]
  #[doc = " av_fast_malloc(&buf, &current_size, size_needed);"]
  #[doc = " if (!buf) {"]
  #[doc = "     // Allocation failed; buf already freed"]
  #[doc = "     return AVERROR(ENOMEM);"]
  #[doc = " }"]
  #[doc = " @endcode"]
  #[doc = ""]
  #[doc = " @param[in,out] ptr      Pointer to pointer to an already allocated buffer."]
  #[doc = "                         `*ptr` will be overwritten with pointer to new"]
  #[doc = "                         buffer on success or `NULL` on failure"]
  #[doc = " @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is"]
  #[doc = "                         updated to the new allocated size, in particular 0"]
  #[doc = "                         in case of failure."]
  #[doc = " @param[in]     min_size Desired minimal size of buffer `*ptr`"]
  #[doc = " @see av_realloc()"]
  #[doc = " @see av_fast_mallocz()"]
  pub fn av_fast_malloc(
    ptr: *mut ::std::os::raw::c_void,
    size: *mut ::std::os::raw::c_uint,
    min_size: size_t,
  );
}
extern "C" {
  #[doc = " Allocate and clear a buffer, reusing the given one if large enough."]
  #[doc = ""]
  #[doc = " Like av_fast_malloc(), but all newly allocated space is initially cleared."]
  #[doc = " Reused buffer is not cleared."]
  #[doc = ""]
  #[doc = " `*ptr` is allowed to be `NULL`, in which case allocation always happens if"]
  #[doc = " `size_needed` is greater than 0."]
  #[doc = ""]
  #[doc = " @param[in,out] ptr      Pointer to pointer to an already allocated buffer."]
  #[doc = "                         `*ptr` will be overwritten with pointer to new"]
  #[doc = "                         buffer on success or `NULL` on failure"]
  #[doc = " @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is"]
  #[doc = "                         updated to the new allocated size, in particular 0"]
  #[doc = "                         in case of failure."]
  #[doc = " @param[in]     min_size Desired minimal size of buffer `*ptr`"]
  #[doc = " @see av_fast_malloc()"]
  pub fn av_fast_mallocz(
    ptr: *mut ::std::os::raw::c_void,
    size: *mut ::std::os::raw::c_uint,
    min_size: size_t,
  );
}
extern "C" {
  #[doc = " Free a memory block which has been allocated with a function of av_malloc()"]
  #[doc = " or av_realloc() family."]
  #[doc = ""]
  #[doc = " @param ptr Pointer to the memory block which should be freed."]
  #[doc = ""]
  #[doc = " @note `ptr = NULL` is explicitly allowed."]
  #[doc = " @note It is recommended that you use av_freep() instead, to prevent leaving"]
  #[doc = "       behind dangling pointers."]
  #[doc = " @see av_freep()"]
  pub fn av_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
  #[doc = " Free a memory block which has been allocated with a function of av_malloc()"]
  #[doc = " or av_realloc() family, and set the pointer pointing to it to `NULL`."]
  #[doc = ""]
  #[doc = " @code{.c}"]
  #[doc = " uint8_t *buf = av_malloc(16);"]
  #[doc = " av_free(buf);"]
  #[doc = " // buf now contains a dangling pointer to freed memory, and accidental"]
  #[doc = " // dereference of buf will result in a use-after-free, which may be a"]
  #[doc = " // security risk."]
  #[doc = ""]
  #[doc = " uint8_t *buf = av_malloc(16);"]
  #[doc = " av_freep(&buf);"]
  #[doc = " // buf is now NULL, and accidental dereference will only result in a"]
  #[doc = " // NULL-pointer dereference."]
  #[doc = " @endcode"]
  #[doc = ""]
  #[doc = " @param ptr Pointer to the pointer to the memory block which should be freed"]
  #[doc = " @note `*ptr = NULL` is safe and leads to no action."]
  #[doc = " @see av_free()"]
  pub fn av_freep(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
  #[doc = " Duplicate a string."]
  #[doc = ""]
  #[doc = " @param s String to be duplicated"]
  #[doc = " @return Pointer to a newly-allocated string containing a"]
  #[doc = "         copy of `s` or `NULL` if the string cannot be allocated"]
  #[doc = " @see av_strndup()"]
  pub fn av_strdup(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Duplicate a substring of a string."]
  #[doc = ""]
  #[doc = " @param s   String to be duplicated"]
  #[doc = " @param len Maximum length of the resulting string (not counting the"]
  #[doc = "            terminating byte)"]
  #[doc = " @return Pointer to a newly-allocated string containing a"]
  #[doc = "         substring of `s` or `NULL` if the string cannot be allocated"]
  pub fn av_strndup(s: *const ::std::os::raw::c_char, len: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Duplicate a buffer with av_malloc()."]
  #[doc = ""]
  #[doc = " @param p    Buffer to be duplicated"]
  #[doc = " @param size Size in bytes of the buffer copied"]
  #[doc = " @return Pointer to a newly allocated buffer containing a"]
  #[doc = "         copy of `p` or `NULL` if the buffer cannot be allocated"]
  pub fn av_memdup(p: *const ::std::os::raw::c_void, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  #[doc = " Overlapping memcpy() implementation."]
  #[doc = ""]
  #[doc = " @param dst  Destination buffer"]
  #[doc = " @param back Number of bytes back to start copying (i.e. the initial size of"]
  #[doc = "             the overlapping window); must be > 0"]
  #[doc = " @param cnt  Number of bytes to copy; must be >= 0"]
  #[doc = ""]
  #[doc = " @note `cnt > back` is valid, this will copy the bytes we just copied,"]
  #[doc = "       thus creating a repeating pattern with a period length of `back`."]
  pub fn av_memcpy_backptr(dst: *mut u8, back: ::std::os::raw::c_int, cnt: ::std::os::raw::c_int);
}
extern "C" {
  #[doc = " Add the pointer to an element to a dynamic array."]
  #[doc = ""]
  #[doc = " The array to grow is supposed to be an array of pointers to"]
  #[doc = " structures, and the element to add must be a pointer to an already"]
  #[doc = " allocated structure."]
  #[doc = ""]
  #[doc = " The array is reallocated when its size reaches powers of 2."]
  #[doc = " Therefore, the amortized cost of adding an element is constant."]
  #[doc = ""]
  #[doc = " In case of success, the pointer to the array is updated in order to"]
  #[doc = " point to the new grown array, and the number pointed to by `nb_ptr`"]
  #[doc = " is incremented."]
  #[doc = " In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and"]
  #[doc = " `*nb_ptr` is set to 0."]
  #[doc = ""]
  #[doc = " @param[in,out] tab_ptr Pointer to the array to grow"]
  #[doc = " @param[in,out] nb_ptr  Pointer to the number of elements in the array"]
  #[doc = " @param[in]     elem    Element to add"]
  #[doc = " @see av_dynarray_add_nofree(), av_dynarray2_add()"]
  pub fn av_dynarray_add(
    tab_ptr: *mut ::std::os::raw::c_void,
    nb_ptr: *mut ::std::os::raw::c_int,
    elem: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  #[doc = " Add an element to a dynamic array."]
  #[doc = ""]
  #[doc = " Function has the same functionality as av_dynarray_add(),"]
  #[doc = " but it doesn't free memory on fails. It returns error code"]
  #[doc = " instead and leave current buffer untouched."]
  #[doc = ""]
  #[doc = " @return >=0 on success, negative otherwise"]
  #[doc = " @see av_dynarray_add(), av_dynarray2_add()"]
  pub fn av_dynarray_add_nofree(
    tab_ptr: *mut ::std::os::raw::c_void,
    nb_ptr: *mut ::std::os::raw::c_int,
    elem: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Add an element of size `elem_size` to a dynamic array."]
  #[doc = ""]
  #[doc = " The array is reallocated when its number of elements reaches powers of 2."]
  #[doc = " Therefore, the amortized cost of adding an element is constant."]
  #[doc = ""]
  #[doc = " In case of success, the pointer to the array is updated in order to"]
  #[doc = " point to the new grown array, and the number pointed to by `nb_ptr`"]
  #[doc = " is incremented."]
  #[doc = " In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and"]
  #[doc = " `*nb_ptr` is set to 0."]
  #[doc = ""]
  #[doc = " @param[in,out] tab_ptr   Pointer to the array to grow"]
  #[doc = " @param[in,out] nb_ptr    Pointer to the number of elements in the array"]
  #[doc = " @param[in]     elem_size Size in bytes of an element in the array"]
  #[doc = " @param[in]     elem_data Pointer to the data of the element to add. If"]
  #[doc = "                          `NULL`, the space of the newly added element is"]
  #[doc = "                          allocated but left uninitialized."]
  #[doc = ""]
  #[doc = " @return Pointer to the data of the element to copy in the newly allocated"]
  #[doc = "         space"]
  #[doc = " @see av_dynarray_add(), av_dynarray_add_nofree()"]
  pub fn av_dynarray2_add(
    tab_ptr: *mut *mut ::std::os::raw::c_void,
    nb_ptr: *mut ::std::os::raw::c_int,
    elem_size: size_t,
    elem_data: *const u8,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  #[doc = " Set the maximum size that may be allocated in one block."]
  #[doc = ""]
  #[doc = " The value specified with this function is effective for all libavutil's @ref"]
  #[doc = " lavu_mem_funcs \"heap management functions.\""]
  #[doc = ""]
  #[doc = " By default, the max value is defined as `INT_MAX`."]
  #[doc = ""]
  #[doc = " @param max Value to be set as the new maximum size"]
  #[doc = ""]
  #[doc = " @warning Exercise extreme caution when using this function. Don't touch"]
  #[doc = "          this if you do not understand the full consequence of doing so."]
  pub fn av_max_alloc(max: size_t);
}
#[doc = " Rational number (pair of numerator and denominator)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRational {
  #[doc = "< Numerator"]
  pub num: ::std::os::raw::c_int,
  #[doc = "< Denominator"]
  pub den: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVRational() {
  assert_eq!(
    ::std::mem::size_of::<AVRational>(),
    8usize,
    concat!("Size of: ", stringify!(AVRational))
  );
  assert_eq!(
    ::std::mem::align_of::<AVRational>(),
    4usize,
    concat!("Alignment of ", stringify!(AVRational))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVRational>())).num as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(AVRational),
      "::",
      stringify!(num)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVRational>())).den as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(AVRational),
      "::",
      stringify!(den)
    )
  );
}
extern "C" {
  #[doc = " Reduce a fraction."]
  #[doc = ""]
  #[doc = " This is useful for framerate calculations."]
  #[doc = ""]
  #[doc = " @param[out] dst_num Destination numerator"]
  #[doc = " @param[out] dst_den Destination denominator"]
  #[doc = " @param[in]      num Source numerator"]
  #[doc = " @param[in]      den Source denominator"]
  #[doc = " @param[in]      max Maximum allowed values for `dst_num` & `dst_den`"]
  #[doc = " @return 1 if the operation is exact, 0 otherwise"]
  pub fn av_reduce(
    dst_num: *mut ::std::os::raw::c_int,
    dst_den: *mut ::std::os::raw::c_int,
    num: i64,
    den: i64,
    max: i64,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Multiply two rationals."]
  #[doc = " @param b First rational"]
  #[doc = " @param c Second rational"]
  #[doc = " @return b*c"]
  pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
  #[doc = " Divide one rational by another."]
  #[doc = " @param b First rational"]
  #[doc = " @param c Second rational"]
  #[doc = " @return b/c"]
  pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
  #[doc = " Add two rationals."]
  #[doc = " @param b First rational"]
  #[doc = " @param c Second rational"]
  #[doc = " @return b+c"]
  pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
  #[doc = " Subtract one rational from another."]
  #[doc = " @param b First rational"]
  #[doc = " @param c Second rational"]
  #[doc = " @return b-c"]
  pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
  #[doc = " Convert a double precision floating point number to a rational."]
  #[doc = ""]
  #[doc = " In case of infinity, the returned value is expressed as `{1, 0}` or"]
  #[doc = " `{-1, 0}` depending on the sign."]
  #[doc = ""]
  #[doc = " @param d   `double` to convert"]
  #[doc = " @param max Maximum allowed numerator and denominator"]
  #[doc = " @return `d` in AVRational form"]
  #[doc = " @see av_q2d()"]
  pub fn av_d2q(d: f64, max: ::std::os::raw::c_int) -> AVRational;
}
extern "C" {
  #[doc = " Find which of the two rationals is closer to another rational."]
  #[doc = ""]
  #[doc = " @param q     Rational to be compared against"]
  #[doc = " @param q1,q2 Rationals to be tested"]
  #[doc = " @return One of the following values:"]
  #[doc = "         - 1 if `q1` is nearer to `q` than `q2`"]
  #[doc = "         - -1 if `q2` is nearer to `q` than `q1`"]
  #[doc = "         - 0 if they have the same distance"]
  pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Find the value in a list of rationals nearest a given reference rational."]
  #[doc = ""]
  #[doc = " @param q      Reference rational"]
  #[doc = " @param q_list Array of rationals terminated by `{0, 0}`"]
  #[doc = " @return Index of the nearest value found in the array"]
  pub fn av_find_nearest_q_idx(q: AVRational, q_list: *const AVRational) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point"]
  #[doc = " format."]
  #[doc = ""]
  #[doc = " @param q Rational to be converted"]
  #[doc = " @return Equivalent floating-point value, expressed as an unsigned 32-bit"]
  #[doc = "         integer."]
  #[doc = " @note The returned value is platform-indepedant."]
  pub fn av_q2intfloat(q: AVRational) -> u32;
}
extern "C" {
  #[doc = " Return the best rational so that a and b are multiple of it."]
  #[doc = " If the resulting denominator is larger than max_den, return def."]
  pub fn av_gcd_q(
    a: AVRational,
    b: AVRational,
    max_den: ::std::os::raw::c_int,
    def: AVRational,
  ) -> AVRational;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat32 {
  pub i: u32,
  pub f: f32,
}
#[test]
fn bindgen_test_layout_av_intfloat32() {
  assert_eq!(
    ::std::mem::size_of::<av_intfloat32>(),
    4usize,
    concat!("Size of: ", stringify!(av_intfloat32))
  );
  assert_eq!(
    ::std::mem::align_of::<av_intfloat32>(),
    4usize,
    concat!("Alignment of ", stringify!(av_intfloat32))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<av_intfloat32>())).i as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(av_intfloat32),
      "::",
      stringify!(i)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<av_intfloat32>())).f as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(av_intfloat32),
      "::",
      stringify!(f)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat64 {
  pub i: u64,
  pub f: f64,
}
#[test]
fn bindgen_test_layout_av_intfloat64() {
  assert_eq!(
    ::std::mem::size_of::<av_intfloat64>(),
    8usize,
    concat!("Size of: ", stringify!(av_intfloat64))
  );
  assert_eq!(
    ::std::mem::align_of::<av_intfloat64>(),
    8usize,
    concat!("Alignment of ", stringify!(av_intfloat64))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<av_intfloat64>())).i as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(av_intfloat64),
      "::",
      stringify!(i)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<av_intfloat64>())).f as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(av_intfloat64),
      "::",
      stringify!(f)
    )
  );
}
#[doc = "< Round toward zero."]
pub const AVRounding_AV_ROUND_ZERO: AVRounding = 0;
#[doc = "< Round away from zero."]
pub const AVRounding_AV_ROUND_INF: AVRounding = 1;
#[doc = "< Round toward -infinity."]
pub const AVRounding_AV_ROUND_DOWN: AVRounding = 2;
#[doc = "< Round toward +infinity."]
pub const AVRounding_AV_ROUND_UP: AVRounding = 3;
#[doc = "< Round to nearest and halfway cases away from zero."]
pub const AVRounding_AV_ROUND_NEAR_INF: AVRounding = 5;
#[doc = " Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through"]
#[doc = " unchanged, avoiding special cases for #AV_NOPTS_VALUE."]
#[doc = ""]
#[doc = " Unlike other values of the enumeration AVRounding, this value is a"]
#[doc = " bitmask that must be used in conjunction with another value of the"]
#[doc = " enumeration through a bitwise OR, in order to set behavior for normal"]
#[doc = " cases."]
#[doc = ""]
#[doc = " @code{.c}"]
#[doc = " av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);"]
#[doc = " // Rescaling 3:"]
#[doc = " //     Calculating 3 * 1 / 2"]
#[doc = " //     3 / 2 is rounded up to 2"]
#[doc = " //     => 2"]
#[doc = ""]
#[doc = " av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);"]
#[doc = " // Rescaling AV_NOPTS_VALUE:"]
#[doc = " //     AV_NOPTS_VALUE == INT64_MIN"]
#[doc = " //     AV_NOPTS_VALUE is passed through"]
#[doc = " //     => AV_NOPTS_VALUE"]
#[doc = " @endcode"]
pub const AVRounding_AV_ROUND_PASS_MINMAX: AVRounding = 8192;
#[doc = " Rounding methods."]
pub type AVRounding = ::std::os::raw::c_uint;
extern "C" {
  #[doc = " Compute the greatest common divisor of two integer operands."]
  #[doc = ""]
  #[doc = " @param a,b Operands"]
  #[doc = " @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;"]
  #[doc = " if a == 0 and b == 0, returns 0."]
  pub fn av_gcd(a: i64, b: i64) -> i64;
}
extern "C" {
  #[doc = " Rescale a 64-bit integer with rounding to nearest."]
  #[doc = ""]
  #[doc = " The operation is mathematically equivalent to `a * b / c`, but writing that"]
  #[doc = " directly can overflow."]
  #[doc = ""]
  #[doc = " This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF."]
  #[doc = ""]
  #[doc = " @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()"]
  pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
}
extern "C" {
  #[doc = " Rescale a 64-bit integer with specified rounding."]
  #[doc = ""]
  #[doc = " The operation is mathematically equivalent to `a * b / c`, but writing that"]
  #[doc = " directly can overflow, and does not support different rounding methods."]
  #[doc = " If the result is not representable then INT64_MIN is returned."]
  #[doc = ""]
  #[doc = " @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()"]
  pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: AVRounding) -> i64;
}
extern "C" {
  #[doc = " Rescale a 64-bit integer by 2 rational numbers."]
  #[doc = ""]
  #[doc = " The operation is mathematically equivalent to `a * bq / cq`."]
  #[doc = ""]
  #[doc = " This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF."]
  #[doc = ""]
  #[doc = " @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()"]
  pub fn av_rescale_q(a: i64, bq: AVRational, cq: AVRational) -> i64;
}
extern "C" {
  #[doc = " Rescale a 64-bit integer by 2 rational numbers with specified rounding."]
  #[doc = ""]
  #[doc = " The operation is mathematically equivalent to `a * bq / cq`."]
  #[doc = ""]
  #[doc = " @see av_rescale(), av_rescale_rnd(), av_rescale_q()"]
  pub fn av_rescale_q_rnd(a: i64, bq: AVRational, cq: AVRational, rnd: AVRounding) -> i64;
}
extern "C" {
  #[doc = " Compare two timestamps each in its own time base."]
  #[doc = ""]
  #[doc = " @return One of the following values:"]
  #[doc = "         - -1 if `ts_a` is before `ts_b`"]
  #[doc = "         - 1 if `ts_a` is after `ts_b`"]
  #[doc = "         - 0 if they represent the same position"]
  #[doc = ""]
  #[doc = " @warning"]
  #[doc = " The result of the function is undefined if one of the timestamps is outside"]
  #[doc = " the `int64_t` range when represented in the other's timebase."]
  pub fn av_compare_ts(
    ts_a: i64,
    tb_a: AVRational,
    ts_b: i64,
    tb_b: AVRational,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Compare the remainders of two integer operands divided by a common divisor."]
  #[doc = ""]
  #[doc = " In other words, compare the least significant `log2(mod)` bits of integers"]
  #[doc = " `a` and `b`."]
  #[doc = ""]
  #[doc = " @code{.c}"]
  #[doc = " av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)"]
  #[doc = " av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)"]
  #[doc = " @endcode"]
  #[doc = ""]
  #[doc = " @param a,b Operands"]
  #[doc = " @param mod Divisor; must be a power of 2"]
  #[doc = " @return"]
  #[doc = "         - a negative value if `a % mod < b % mod`"]
  #[doc = "         - a positive value if `a % mod > b % mod`"]
  #[doc = "         - zero             if `a % mod == b % mod`"]
  pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
}
extern "C" {
  #[doc = " Rescale a timestamp while preserving known durations."]
  #[doc = ""]
  #[doc = " This function is designed to be called per audio packet to scale the input"]
  #[doc = " timestamp to a different time base. Compared to a simple av_rescale_q()"]
  #[doc = " call, this function is robust against possible inconsistent frame durations."]
  #[doc = ""]
  #[doc = " The `last` parameter is a state variable that must be preserved for all"]
  #[doc = " subsequent calls for the same stream. For the first call, `*last` should be"]
  #[doc = " initialized to #AV_NOPTS_VALUE."]
  #[doc = ""]
  #[doc = " @param[in]     in_tb    Input time base"]
  #[doc = " @param[in]     in_ts    Input timestamp"]
  #[doc = " @param[in]     fs_tb    Duration time base; typically this is finer-grained"]
  #[doc = "                         (greater) than `in_tb` and `out_tb`"]
  #[doc = " @param[in]     duration Duration till the next call to this function (i.e."]
  #[doc = "                         duration of the current packet/frame)"]
  #[doc = " @param[in,out] last     Pointer to a timestamp expressed in terms of"]
  #[doc = "                         `fs_tb`, acting as a state variable"]
  #[doc = " @param[in]     out_tb   Output timebase"]
  #[doc = " @return        Timestamp expressed in terms of `out_tb`"]
  #[doc = ""]
  #[doc = " @note In the context of this function, \"duration\" is in term of samples, not"]
  #[doc = "       seconds."]
  pub fn av_rescale_delta(
    in_tb: AVRational,
    in_ts: i64,
    fs_tb: AVRational,
    duration: ::std::os::raw::c_int,
    last: *mut i64,
    out_tb: AVRational,
  ) -> i64;
}
extern "C" {
  #[doc = " Add a value to a timestamp."]
  #[doc = ""]
  #[doc = " This function guarantees that when the same value is repeatly added that"]
  #[doc = " no accumulation of rounding errors occurs."]
  #[doc = ""]
  #[doc = " @param[in] ts     Input timestamp"]
  #[doc = " @param[in] ts_tb  Input timestamp time base"]
  #[doc = " @param[in] inc    Value to be added"]
  #[doc = " @param[in] inc_tb Time base of `inc`"]
  pub fn av_add_stable(ts_tb: AVRational, ts: i64, inc_tb: AVRational, inc: i64) -> i64;
}
pub const AVClassCategory_AV_CLASS_CATEGORY_NA: AVClassCategory = 0;
pub const AVClassCategory_AV_CLASS_CATEGORY_INPUT: AVClassCategory = 1;
pub const AVClassCategory_AV_CLASS_CATEGORY_OUTPUT: AVClassCategory = 2;
pub const AVClassCategory_AV_CLASS_CATEGORY_MUXER: AVClassCategory = 3;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEMUXER: AVClassCategory = 4;
pub const AVClassCategory_AV_CLASS_CATEGORY_ENCODER: AVClassCategory = 5;
pub const AVClassCategory_AV_CLASS_CATEGORY_DECODER: AVClassCategory = 6;
pub const AVClassCategory_AV_CLASS_CATEGORY_FILTER: AVClassCategory = 7;
pub const AVClassCategory_AV_CLASS_CATEGORY_BITSTREAM_FILTER: AVClassCategory = 8;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWSCALER: AVClassCategory = 9;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWRESAMPLER: AVClassCategory = 10;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT: AVClassCategory = 40;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT: AVClassCategory = 41;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT: AVClassCategory = 42;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT: AVClassCategory = 43;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_OUTPUT: AVClassCategory = 44;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_INPUT: AVClassCategory = 45;
#[doc = "< not part of ABI/API"]
pub const AVClassCategory_AV_CLASS_CATEGORY_NB: AVClassCategory = 46;
pub type AVClassCategory = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOptionRanges {
  _unused: [u8; 0],
}
#[doc = " Describe the class of an AVClass context structure. That is an"]
#[doc = " arbitrary struct of which the first field is a pointer to an"]
#[doc = " AVClass struct (e.g. AVCodecContext, AVFormatContext etc.)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVClass {
  #[doc = " The name of the class; usually it is the same name as the"]
  #[doc = " context structure type to which the AVClass is associated."]
  pub class_name: *const ::std::os::raw::c_char,
  #[doc = " A pointer to a function which returns the name of a context"]
  #[doc = " instance ctx associated with the class."]
  pub item_name: ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
  >,
  #[doc = " a pointer to the first option specified in the class if any or NULL"]
  #[doc = ""]
  #[doc = " @see av_set_default_options()"]
  pub option: *mut AVOption,
  #[doc = " LIBAVUTIL_VERSION with which this structure was created."]
  #[doc = " This is used to allow fields to be added without requiring major"]
  #[doc = " version bumps everywhere."]
  pub version: ::std::os::raw::c_int,
  #[doc = " Offset in the structure where log_level_offset is stored."]
  #[doc = " 0 means there is no such variable"]
  pub log_level_offset_offset: ::std::os::raw::c_int,
  #[doc = " Offset in the structure where a pointer to the parent context for"]
  #[doc = " logging is stored. For example a decoder could pass its AVCodecContext"]
  #[doc = " to eval as such a parent context, which an av_log() implementation"]
  #[doc = " could then leverage to display the parent context."]
  #[doc = " The offset can be NULL."]
  pub parent_log_context_offset: ::std::os::raw::c_int,
  #[doc = " Return next AVOptions-enabled child or NULL"]
  pub child_next: ::std::option::Option<
    unsafe extern "C" fn(
      obj: *mut ::std::os::raw::c_void,
      prev: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
  >,
  #[doc = " Return an AVClass corresponding to the next potential"]
  #[doc = " AVOptions-enabled child."]
  #[doc = ""]
  #[doc = " The difference between child_next and this is that"]
  #[doc = " child_next iterates over _already existing_ objects, while"]
  #[doc = " child_class_next iterates over _all possible_ children."]
  pub child_class_next:
    ::std::option::Option<unsafe extern "C" fn(prev: *const AVClass) -> *const AVClass>,
  #[doc = " Category used for visualization (like color)"]
  #[doc = " This is only set if the category is equal for all objects using this class."]
  #[doc = " available since version (51 << 16 | 56 << 8 | 100)"]
  pub category: AVClassCategory,
  #[doc = " Callback to return the category."]
  #[doc = " available since version (51 << 16 | 59 << 8 | 100)"]
  pub get_category: ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> AVClassCategory,
  >,
  #[doc = " Callback to return the supported/allowed ranges."]
  #[doc = " available since version (52.12)"]
  pub query_ranges: ::std::option::Option<
    unsafe extern "C" fn(
      arg1: *mut *mut AVOptionRanges,
      obj: *mut ::std::os::raw::c_void,
      key: *const ::std::os::raw::c_char,
      flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
  >,
  #[doc = " Iterate over the AVClasses corresponding to potential AVOptions-enabled"]
  #[doc = " children."]
  #[doc = ""]
  #[doc = " @param iter pointer to opaque iteration state. The caller must initialize"]
  #[doc = "             *iter to NULL before the first call."]
  #[doc = " @return AVClass for the next AVOptions-enabled child or NULL if there are"]
  #[doc = "         no more such children."]
  #[doc = ""]
  #[doc = " @note The difference between child_next and this is that child_next"]
  #[doc = "       iterates over _already existing_ objects, while child_class_iterate"]
  #[doc = "       iterates over _all possible_ children."]
  pub child_class_iterate: ::std::option::Option<
    unsafe extern "C" fn(iter: *mut *mut ::std::os::raw::c_void) -> *const AVClass,
  >,
}
#[test]
fn bindgen_test_layout_AVClass() {
  assert_eq!(
    ::std::mem::size_of::<AVClass>(),
    88usize,
    concat!("Size of: ", stringify!(AVClass))
  );
  assert_eq!(
    ::std::mem::align_of::<AVClass>(),
    8usize,
    concat!("Alignment of ", stringify!(AVClass))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVClass>())).class_name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(AVClass),
      "::",
      stringify!(class_name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVClass>())).item_name as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(AVClass),
      "::",
      stringify!(item_name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVClass>())).option as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(AVClass),
      "::",
      stringify!(option)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVClass>())).version as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(AVClass),
      "::",
      stringify!(version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVClass>())).log_level_offset_offset as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(AVClass),
      "::",
      stringify!(log_level_offset_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVClass>())).parent_log_context_offset as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(AVClass),
      "::",
      stringify!(parent_log_context_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVClass>())).child_next as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(AVClass),
      "::",
      stringify!(child_next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVClass>())).child_class_next as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(AVClass),
      "::",
      stringify!(child_class_next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVClass>())).category as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(AVClass),
      "::",
      stringify!(category)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVClass>())).get_category as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(AVClass),
      "::",
      stringify!(get_category)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVClass>())).query_ranges as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(AVClass),
      "::",
      stringify!(query_ranges)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVClass>())).child_class_iterate as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(AVClass),
      "::",
      stringify!(child_class_iterate)
    )
  );
}
extern "C" {
  #[doc = " Send the specified message to the log if the level is less than or equal"]
  #[doc = " to the current av_log_level. By default, all logging messages are sent to"]
  #[doc = " stderr. This behavior can be altered by setting a different logging callback"]
  #[doc = " function."]
  #[doc = " @see av_log_set_callback"]
  #[doc = ""]
  #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
  #[doc = "        pointer to an AVClass struct or NULL if general log."]
  #[doc = " @param level The importance level of the message expressed using a @ref"]
  #[doc = "        lavu_log_constants \"Logging Constant\"."]
  #[doc = " @param fmt The format string (printf-compatible) that specifies how"]
  #[doc = "        subsequent arguments are converted to output."]
  pub fn av_log(
    avcl: *mut ::std::os::raw::c_void,
    level: ::std::os::raw::c_int,
    fmt: *const ::std::os::raw::c_char,
    ...
  );
}
extern "C" {
  #[doc = " Send the specified message to the log once with the initial_level and then with"]
  #[doc = " the subsequent_level. By default, all logging messages are sent to"]
  #[doc = " stderr. This behavior can be altered by setting a different logging callback"]
  #[doc = " function."]
  #[doc = " @see av_log"]
  #[doc = ""]
  #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
  #[doc = "        pointer to an AVClass struct or NULL if general log."]
  #[doc = " @param initial_level importance level of the message expressed using a @ref"]
  #[doc = "        lavu_log_constants \"Logging Constant\" for the first occurance."]
  #[doc = " @param subsequent_level importance level of the message expressed using a @ref"]
  #[doc = "        lavu_log_constants \"Logging Constant\" after the first occurance."]
  #[doc = " @param fmt The format string (printf-compatible) that specifies how"]
  #[doc = "        subsequent arguments are converted to output."]
  #[doc = " @param state a variable to keep trak of if a message has already been printed"]
  #[doc = "        this must be initialized to 0 before the first use. The same state"]
  #[doc = "        must not be accessed by 2 Threads simultaneously."]
  pub fn av_log_once(
    avcl: *mut ::std::os::raw::c_void,
    initial_level: ::std::os::raw::c_int,
    subsequent_level: ::std::os::raw::c_int,
    state: *mut ::std::os::raw::c_int,
    fmt: *const ::std::os::raw::c_char,
    ...
  );
}
extern "C" {
  #[doc = " Send the specified message to the log if the level is less than or equal"]
  #[doc = " to the current av_log_level. By default, all logging messages are sent to"]
  #[doc = " stderr. This behavior can be altered by setting a different logging callback"]
  #[doc = " function."]
  #[doc = " @see av_log_set_callback"]
  #[doc = ""]
  #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
  #[doc = "        pointer to an AVClass struct."]
  #[doc = " @param level The importance level of the message expressed using a @ref"]
  #[doc = "        lavu_log_constants \"Logging Constant\"."]
  #[doc = " @param fmt The format string (printf-compatible) that specifies how"]
  #[doc = "        subsequent arguments are converted to output."]
  #[doc = " @param vl The arguments referenced by the format string."]
  pub fn av_vlog(
    avcl: *mut ::std::os::raw::c_void,
    level: ::std::os::raw::c_int,
    fmt: *const ::std::os::raw::c_char,
    vl: *mut __va_list_tag,
  );
}
extern "C" {
  #[doc = " Get the current log level"]
  #[doc = ""]
  #[doc = " @see lavu_log_constants"]
  #[doc = ""]
  #[doc = " @return Current log level"]
  pub fn av_log_get_level() -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Set the log level"]
  #[doc = ""]
  #[doc = " @see lavu_log_constants"]
  #[doc = ""]
  #[doc = " @param level Logging level"]
  pub fn av_log_set_level(level: ::std::os::raw::c_int);
}
extern "C" {
  #[doc = " Set the logging callback"]
  #[doc = ""]
  #[doc = " @note The callback must be thread safe, even if the application does not use"]
  #[doc = "       threads itself as some codecs are multithreaded."]
  #[doc = ""]
  #[doc = " @see av_log_default_callback"]
  #[doc = ""]
  #[doc = " @param callback A logging function with a compatible signature."]
  pub fn av_log_set_callback(
    callback: ::std::option::Option<
      unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
      ),
    >,
  );
}
extern "C" {
  #[doc = " Default logging callback"]
  #[doc = ""]
  #[doc = " It prints the message to stderr, optionally colorizing it."]
  #[doc = ""]
  #[doc = " @param avcl A pointer to an arbitrary struct of which the first field is a"]
  #[doc = "        pointer to an AVClass struct."]
  #[doc = " @param level The importance level of the message expressed using a @ref"]
  #[doc = "        lavu_log_constants \"Logging Constant\"."]
  #[doc = " @param fmt The format string (printf-compatible) that specifies how"]
  #[doc = "        subsequent arguments are converted to output."]
  #[doc = " @param vl The arguments referenced by the format string."]
  pub fn av_log_default_callback(
    avcl: *mut ::std::os::raw::c_void,
    level: ::std::os::raw::c_int,
    fmt: *const ::std::os::raw::c_char,
    vl: *mut __va_list_tag,
  );
}
extern "C" {
  #[doc = " Return the context name"]
  #[doc = ""]
  #[doc = " @param  ctx The AVClass context"]
  #[doc = ""]
  #[doc = " @return The AVClass class_name"]
  pub fn av_default_item_name(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn av_default_get_category(ptr: *mut ::std::os::raw::c_void) -> AVClassCategory;
}
extern "C" {
  #[doc = " Format a line of log the same way as the default callback."]
  #[doc = " @param line          buffer to receive the formatted line"]
  #[doc = " @param line_size     size of the buffer"]
  #[doc = " @param print_prefix  used to store whether the prefix must be printed;"]
  #[doc = "                      must point to a persistent integer initially set to 1"]
  pub fn av_log_format_line(
    ptr: *mut ::std::os::raw::c_void,
    level: ::std::os::raw::c_int,
    fmt: *const ::std::os::raw::c_char,
    vl: *mut __va_list_tag,
    line: *mut ::std::os::raw::c_char,
    line_size: ::std::os::raw::c_int,
    print_prefix: *mut ::std::os::raw::c_int,
  );
}
extern "C" {
  #[doc = " Format a line of log the same way as the default callback."]
  #[doc = " @param line          buffer to receive the formatted line;"]
  #[doc = "                      may be NULL if line_size is 0"]
  #[doc = " @param line_size     size of the buffer; at most line_size-1 characters will"]
  #[doc = "                      be written to the buffer, plus one null terminator"]
  #[doc = " @param print_prefix  used to store whether the prefix must be printed;"]
  #[doc = "                      must point to a persistent integer initially set to 1"]
  #[doc = " @return Returns a negative value if an error occurred, otherwise returns"]
  #[doc = "         the number of characters that would have been written for a"]
  #[doc = "         sufficiently large buffer, not including the terminating null"]
  #[doc = "         character. If the return value is not less than line_size, it means"]
  #[doc = "         that the log message was truncated to fit the buffer."]
  pub fn av_log_format_line2(
    ptr: *mut ::std::os::raw::c_void,
    level: ::std::os::raw::c_int,
    fmt: *const ::std::os::raw::c_char,
    vl: *mut __va_list_tag,
    line: *mut ::std::os::raw::c_char,
    line_size: ::std::os::raw::c_int,
    print_prefix: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn av_log_set_flags(arg: ::std::os::raw::c_int);
}
extern "C" {
  pub fn av_log_get_flags() -> ::std::os::raw::c_int;
}
pub const AVPixelFormat_AV_PIX_FMT_NONE: AVPixelFormat = -1;
#[doc = "< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P: AVPixelFormat = 0;
#[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr"]
pub const AVPixelFormat_AV_PIX_FMT_YUYV422: AVPixelFormat = 1;
#[doc = "< packed RGB 8:8:8, 24bpp, RGBRGB..."]
pub const AVPixelFormat_AV_PIX_FMT_RGB24: AVPixelFormat = 2;
#[doc = "< packed RGB 8:8:8, 24bpp, BGRBGR..."]
pub const AVPixelFormat_AV_PIX_FMT_BGR24: AVPixelFormat = 3;
#[doc = "< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P: AVPixelFormat = 4;
#[doc = "< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P: AVPixelFormat = 5;
#[doc = "< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV410P: AVPixelFormat = 6;
#[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV411P: AVPixelFormat = 7;
#[doc = "<        Y        ,  8bpp"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY8: AVPixelFormat = 8;
#[doc = "<        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb"]
pub const AVPixelFormat_AV_PIX_FMT_MONOWHITE: AVPixelFormat = 9;
#[doc = "<        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb"]
pub const AVPixelFormat_AV_PIX_FMT_MONOBLACK: AVPixelFormat = 10;
#[doc = "< 8 bits with AV_PIX_FMT_RGB32 palette"]
pub const AVPixelFormat_AV_PIX_FMT_PAL8: AVPixelFormat = 11;
#[doc = "< planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ420P: AVPixelFormat = 12;
#[doc = "< planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ422P: AVPixelFormat = 13;
#[doc = "< planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ444P: AVPixelFormat = 14;
#[doc = "< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1"]
pub const AVPixelFormat_AV_PIX_FMT_UYVY422: AVPixelFormat = 15;
#[doc = "< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3"]
pub const AVPixelFormat_AV_PIX_FMT_UYYVYY411: AVPixelFormat = 16;
#[doc = "< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_BGR8: AVPixelFormat = 17;
#[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
pub const AVPixelFormat_AV_PIX_FMT_BGR4: AVPixelFormat = 18;
#[doc = "< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_BGR4_BYTE: AVPixelFormat = 19;
#[doc = "< packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_RGB8: AVPixelFormat = 20;
#[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
pub const AVPixelFormat_AV_PIX_FMT_RGB4: AVPixelFormat = 21;
#[doc = "< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_RGB4_BYTE: AVPixelFormat = 22;
#[doc = "< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
pub const AVPixelFormat_AV_PIX_FMT_NV12: AVPixelFormat = 23;
#[doc = "< as above, but U and V bytes are swapped"]
pub const AVPixelFormat_AV_PIX_FMT_NV21: AVPixelFormat = 24;
#[doc = "< packed ARGB 8:8:8:8, 32bpp, ARGBARGB..."]
pub const AVPixelFormat_AV_PIX_FMT_ARGB: AVPixelFormat = 25;
#[doc = "< packed RGBA 8:8:8:8, 32bpp, RGBARGBA..."]
pub const AVPixelFormat_AV_PIX_FMT_RGBA: AVPixelFormat = 26;
#[doc = "< packed ABGR 8:8:8:8, 32bpp, ABGRABGR..."]
pub const AVPixelFormat_AV_PIX_FMT_ABGR: AVPixelFormat = 27;
#[doc = "< packed BGRA 8:8:8:8, 32bpp, BGRABGRA..."]
pub const AVPixelFormat_AV_PIX_FMT_BGRA: AVPixelFormat = 28;
#[doc = "<        Y        , 16bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY16BE: AVPixelFormat = 29;
#[doc = "<        Y        , 16bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY16LE: AVPixelFormat = 30;
#[doc = "< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P: AVPixelFormat = 31;
#[doc = "< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ440P: AVPixelFormat = 32;
#[doc = "< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P: AVPixelFormat = 33;
#[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB48BE: AVPixelFormat = 34;
#[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB48LE: AVPixelFormat = 35;
#[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB565BE: AVPixelFormat = 36;
#[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB565LE: AVPixelFormat = 37;
#[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB555BE: AVPixelFormat = 38;
#[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB555LE: AVPixelFormat = 39;
#[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR565BE: AVPixelFormat = 40;
#[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR565LE: AVPixelFormat = 41;
#[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR555BE: AVPixelFormat = 42;
#[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR555LE: AVPixelFormat = 43;
#[doc = "< HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers"]
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_MOCO: AVPixelFormat = 44;
#[doc = "< HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers"]
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_IDCT: AVPixelFormat = 45;
#[doc = "< HW decoding through VA API, Picture.data[3] contains a VASurfaceID"]
pub const AVPixelFormat_AV_PIX_FMT_VAAPI_VLD: AVPixelFormat = 46;
#[doc = "@}"]
pub const AVPixelFormat_AV_PIX_FMT_VAAPI: AVPixelFormat = 46;
#[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16LE: AVPixelFormat = 47;
#[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16BE: AVPixelFormat = 48;
#[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16LE: AVPixelFormat = 49;
#[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16BE: AVPixelFormat = 50;
#[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16LE: AVPixelFormat = 51;
#[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16BE: AVPixelFormat = 52;
#[doc = "< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer"]
pub const AVPixelFormat_AV_PIX_FMT_DXVA2_VLD: AVPixelFormat = 53;
#[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB444LE: AVPixelFormat = 54;
#[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB444BE: AVPixelFormat = 55;
#[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR444LE: AVPixelFormat = 56;
#[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR444BE: AVPixelFormat = 57;
#[doc = "< 8 bits gray, 8 bits alpha"]
pub const AVPixelFormat_AV_PIX_FMT_YA8: AVPixelFormat = 58;
#[doc = "< alias for AV_PIX_FMT_YA8"]
pub const AVPixelFormat_AV_PIX_FMT_Y400A: AVPixelFormat = 58;
#[doc = "< alias for AV_PIX_FMT_YA8"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY8A: AVPixelFormat = 58;
#[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR48BE: AVPixelFormat = 59;
#[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR48LE: AVPixelFormat = 60;
#[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9BE: AVPixelFormat = 61;
#[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9LE: AVPixelFormat = 62;
#[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10BE: AVPixelFormat = 63;
#[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10LE: AVPixelFormat = 64;
#[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10BE: AVPixelFormat = 65;
#[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10LE: AVPixelFormat = 66;
#[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9BE: AVPixelFormat = 67;
#[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9LE: AVPixelFormat = 68;
#[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10BE: AVPixelFormat = 69;
#[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10LE: AVPixelFormat = 70;
#[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9BE: AVPixelFormat = 71;
#[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9LE: AVPixelFormat = 72;
#[doc = "< planar GBR 4:4:4 24bpp"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP: AVPixelFormat = 73;
pub const AVPixelFormat_AV_PIX_FMT_GBR24P: AVPixelFormat = 73;
#[doc = "< planar GBR 4:4:4 27bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP9BE: AVPixelFormat = 74;
#[doc = "< planar GBR 4:4:4 27bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP9LE: AVPixelFormat = 75;
#[doc = "< planar GBR 4:4:4 30bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP10BE: AVPixelFormat = 76;
#[doc = "< planar GBR 4:4:4 30bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP10LE: AVPixelFormat = 77;
#[doc = "< planar GBR 4:4:4 48bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP16BE: AVPixelFormat = 78;
#[doc = "< planar GBR 4:4:4 48bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP16LE: AVPixelFormat = 79;
#[doc = "< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P: AVPixelFormat = 80;
#[doc = "< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P: AVPixelFormat = 81;
#[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9BE: AVPixelFormat = 82;
#[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9LE: AVPixelFormat = 83;
#[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9BE: AVPixelFormat = 84;
#[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9LE: AVPixelFormat = 85;
#[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9BE: AVPixelFormat = 86;
#[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9LE: AVPixelFormat = 87;
#[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10BE: AVPixelFormat = 88;
#[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10LE: AVPixelFormat = 89;
#[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10BE: AVPixelFormat = 90;
#[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10LE: AVPixelFormat = 91;
#[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10BE: AVPixelFormat = 92;
#[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10LE: AVPixelFormat = 93;
#[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16BE: AVPixelFormat = 94;
#[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16LE: AVPixelFormat = 95;
#[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16BE: AVPixelFormat = 96;
#[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16LE: AVPixelFormat = 97;
#[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16BE: AVPixelFormat = 98;
#[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16LE: AVPixelFormat = 99;
#[doc = "< HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface"]
pub const AVPixelFormat_AV_PIX_FMT_VDPAU: AVPixelFormat = 100;
#[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0"]
pub const AVPixelFormat_AV_PIX_FMT_XYZ12LE: AVPixelFormat = 101;
#[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0"]
pub const AVPixelFormat_AV_PIX_FMT_XYZ12BE: AVPixelFormat = 102;
#[doc = "< interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_NV16: AVPixelFormat = 103;
#[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_NV20LE: AVPixelFormat = 104;
#[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_NV20BE: AVPixelFormat = 105;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBA64BE: AVPixelFormat = 106;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBA64LE: AVPixelFormat = 107;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGRA64BE: AVPixelFormat = 108;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGRA64LE: AVPixelFormat = 109;
#[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb"]
pub const AVPixelFormat_AV_PIX_FMT_YVYU422: AVPixelFormat = 110;
#[doc = "< 16 bits gray, 16 bits alpha (big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YA16BE: AVPixelFormat = 111;
#[doc = "< 16 bits gray, 16 bits alpha (little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YA16LE: AVPixelFormat = 112;
#[doc = "< planar GBRA 4:4:4:4 32bpp"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP: AVPixelFormat = 113;
#[doc = "< planar GBRA 4:4:4:4 64bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16BE: AVPixelFormat = 114;
#[doc = "< planar GBRA 4:4:4:4 64bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16LE: AVPixelFormat = 115;
#[doc = "  HW acceleration through QSV, data[3] contains a pointer to the"]
#[doc = "  mfxFrameSurface1 structure."]
pub const AVPixelFormat_AV_PIX_FMT_QSV: AVPixelFormat = 116;
#[doc = " HW acceleration though MMAL, data[3] contains a pointer to the"]
#[doc = " MMAL_BUFFER_HEADER_T structure."]
pub const AVPixelFormat_AV_PIX_FMT_MMAL: AVPixelFormat = 117;
#[doc = "< HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer"]
pub const AVPixelFormat_AV_PIX_FMT_D3D11VA_VLD: AVPixelFormat = 118;
#[doc = " HW acceleration through CUDA. data[i] contain CUdeviceptr pointers"]
#[doc = " exactly as for system memory frames."]
pub const AVPixelFormat_AV_PIX_FMT_CUDA: AVPixelFormat = 119;
#[doc = "< packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_0RGB: AVPixelFormat = 120;
#[doc = "< packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB0: AVPixelFormat = 121;
#[doc = "< packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_0BGR: AVPixelFormat = 122;
#[doc = "< packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR0: AVPixelFormat = 123;
#[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12BE: AVPixelFormat = 124;
#[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12LE: AVPixelFormat = 125;
#[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14BE: AVPixelFormat = 126;
#[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14LE: AVPixelFormat = 127;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12BE: AVPixelFormat = 128;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12LE: AVPixelFormat = 129;
#[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14BE: AVPixelFormat = 130;
#[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14LE: AVPixelFormat = 131;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12BE: AVPixelFormat = 132;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12LE: AVPixelFormat = 133;
#[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14BE: AVPixelFormat = 134;
#[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14LE: AVPixelFormat = 135;
#[doc = "< planar GBR 4:4:4 36bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP12BE: AVPixelFormat = 136;
#[doc = "< planar GBR 4:4:4 36bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP12LE: AVPixelFormat = 137;
#[doc = "< planar GBR 4:4:4 42bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP14BE: AVPixelFormat = 138;
#[doc = "< planar GBR 4:4:4 42bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP14LE: AVPixelFormat = 139;
#[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ411P: AVPixelFormat = 140;
#[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR8: AVPixelFormat = 141;
#[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB8: AVPixelFormat = 142;
#[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG8: AVPixelFormat = 143;
#[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG8: AVPixelFormat = 144;
#[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16LE: AVPixelFormat = 145;
#[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16BE: AVPixelFormat = 146;
#[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16LE: AVPixelFormat = 147;
#[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16BE: AVPixelFormat = 148;
#[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16LE: AVPixelFormat = 149;
#[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16BE: AVPixelFormat = 150;
#[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16LE: AVPixelFormat = 151;
#[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16BE: AVPixelFormat = 152;
#[doc = "< XVideo Motion Acceleration via common packet passing"]
pub const AVPixelFormat_AV_PIX_FMT_XVMC: AVPixelFormat = 153;
#[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10LE: AVPixelFormat = 154;
#[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10BE: AVPixelFormat = 155;
#[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12LE: AVPixelFormat = 156;
#[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12BE: AVPixelFormat = 157;
#[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_AYUV64LE: AVPixelFormat = 158;
#[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_AYUV64BE: AVPixelFormat = 159;
#[doc = "< hardware decoding through Videotoolbox"]
pub const AVPixelFormat_AV_PIX_FMT_VIDEOTOOLBOX: AVPixelFormat = 160;
#[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P010LE: AVPixelFormat = 161;
#[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P010BE: AVPixelFormat = 162;
#[doc = "< planar GBR 4:4:4:4 48bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12BE: AVPixelFormat = 163;
#[doc = "< planar GBR 4:4:4:4 48bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12LE: AVPixelFormat = 164;
#[doc = "< planar GBR 4:4:4:4 40bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10BE: AVPixelFormat = 165;
#[doc = "< planar GBR 4:4:4:4 40bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10LE: AVPixelFormat = 166;
#[doc = "< hardware decoding through MediaCodec"]
pub const AVPixelFormat_AV_PIX_FMT_MEDIACODEC: AVPixelFormat = 167;
#[doc = "<        Y        , 12bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY12BE: AVPixelFormat = 168;
#[doc = "<        Y        , 12bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY12LE: AVPixelFormat = 169;
#[doc = "<        Y        , 10bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY10BE: AVPixelFormat = 170;
#[doc = "<        Y        , 10bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY10LE: AVPixelFormat = 171;
#[doc = "< like NV12, with 16bpp per component, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P016LE: AVPixelFormat = 172;
#[doc = "< like NV12, with 16bpp per component, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P016BE: AVPixelFormat = 173;
#[doc = " Hardware surfaces for Direct3D11."]
#[doc = ""]
#[doc = " This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11"]
#[doc = " hwaccel API and filtering support AV_PIX_FMT_D3D11 only."]
#[doc = ""]
#[doc = " data[0] contains a ID3D11Texture2D pointer, and data[1] contains the"]
#[doc = " texture array index of the frame as intptr_t if the ID3D11Texture2D is"]
#[doc = " an array texture (or always 0 if it's a normal texture)."]
pub const AVPixelFormat_AV_PIX_FMT_D3D11: AVPixelFormat = 174;
#[doc = "<        Y        , 9bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY9BE: AVPixelFormat = 175;
#[doc = "<        Y        , 9bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY9LE: AVPixelFormat = 176;
#[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32BE: AVPixelFormat = 177;
#[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32LE: AVPixelFormat = 178;
#[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32BE: AVPixelFormat = 179;
#[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32LE: AVPixelFormat = 180;
#[doc = " DRM-managed buffers exposed through PRIME buffer sharing."]
#[doc = ""]
#[doc = " data[0] points to an AVDRMFrameDescriptor."]
pub const AVPixelFormat_AV_PIX_FMT_DRM_PRIME: AVPixelFormat = 181;
#[doc = " Hardware surfaces for OpenCL."]
#[doc = ""]
#[doc = " data[i] contain 2D image objects (typed in C as cl_mem, used"]
#[doc = " in OpenCL as image2d_t) for each plane of the surface."]
pub const AVPixelFormat_AV_PIX_FMT_OPENCL: AVPixelFormat = 182;
#[doc = "<        Y        , 14bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY14BE: AVPixelFormat = 183;
#[doc = "<        Y        , 14bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY14LE: AVPixelFormat = 184;
#[doc = "< IEEE-754 single precision Y, 32bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAYF32BE: AVPixelFormat = 185;
#[doc = "< IEEE-754 single precision Y, 32bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAYF32LE: AVPixelFormat = 186;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P12BE: AVPixelFormat = 187;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P12LE: AVPixelFormat = 188;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P12BE: AVPixelFormat = 189;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P12LE: AVPixelFormat = 190;
#[doc = "< planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
pub const AVPixelFormat_AV_PIX_FMT_NV24: AVPixelFormat = 191;
#[doc = "< as above, but U and V bytes are swapped"]
pub const AVPixelFormat_AV_PIX_FMT_NV42: AVPixelFormat = 192;
#[doc = " Vulkan hardware images."]
#[doc = ""]
#[doc = " data[0] points to an AVVkFrame"]
pub const AVPixelFormat_AV_PIX_FMT_VULKAN: AVPixelFormat = 193;
#[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_Y210BE: AVPixelFormat = 194;
#[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_Y210LE: AVPixelFormat = 195;
#[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_X2RGB10LE: AVPixelFormat = 196;
#[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), big-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_X2RGB10BE: AVPixelFormat = 197;
#[doc = "< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions"]
pub const AVPixelFormat_AV_PIX_FMT_NB: AVPixelFormat = 198;
#[doc = " Pixel format."]
#[doc = ""]
#[doc = " @note"]
#[doc = " AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA"]
#[doc = " color is put together as:"]
#[doc = "  (A << 24) | (R << 16) | (G << 8) | B"]
#[doc = " This is stored as BGRA on little-endian CPU architectures and ARGB on"]
#[doc = " big-endian CPUs."]
#[doc = ""]
#[doc = " @note"]
#[doc = " If the resolution is not a multiple of the chroma subsampling factor"]
#[doc = " then the chroma plane resolution must be rounded up."]
#[doc = ""]
#[doc = " @par"]
#[doc = " When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized"]
#[doc = " image data is stored in AVFrame.data[0]. The palette is transported in"]
#[doc = " AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is"]
#[doc = " formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is"]
#[doc = " also endian-specific). Note also that the individual RGB32 palette"]
#[doc = " components stored in AVFrame.data[1] should be in the range 0..255."]
#[doc = " This is important as many custom PAL8 video codecs that were designed"]
#[doc = " to run on the IBM VGA graphics adapter use 6-bit palette components."]
#[doc = ""]
#[doc = " @par"]
#[doc = " For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like"]
#[doc = " for pal8. This palette is filled in automatically by the function"]
#[doc = " allocating the picture."]
pub type AVPixelFormat = ::std::os::raw::c_int;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED0: AVColorPrimaries = 0;
#[doc = "< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B"]
pub const AVColorPrimaries_AVCOL_PRI_BT709: AVColorPrimaries = 1;
pub const AVColorPrimaries_AVCOL_PRI_UNSPECIFIED: AVColorPrimaries = 2;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED: AVColorPrimaries = 3;
#[doc = "< also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
pub const AVColorPrimaries_AVCOL_PRI_BT470M: AVColorPrimaries = 4;
#[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM"]
pub const AVColorPrimaries_AVCOL_PRI_BT470BG: AVColorPrimaries = 5;
#[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE170M: AVColorPrimaries = 6;
#[doc = "< functionally identical to above"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE240M: AVColorPrimaries = 7;
#[doc = "< colour filters using Illuminant C"]
pub const AVColorPrimaries_AVCOL_PRI_FILM: AVColorPrimaries = 8;
#[doc = "< ITU-R BT2020"]
pub const AVColorPrimaries_AVCOL_PRI_BT2020: AVColorPrimaries = 9;
#[doc = "< SMPTE ST 428-1 (CIE 1931 XYZ)"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE428: AVColorPrimaries = 10;
pub const AVColorPrimaries_AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = 10;
#[doc = "< SMPTE ST 431-2 (2011) / DCI P3"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE431: AVColorPrimaries = 11;
#[doc = "< SMPTE ST 432-1 (2010) / P3 D65 / Display P3"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE432: AVColorPrimaries = 12;
#[doc = "< EBU Tech. 3213-E / JEDEC P22 phosphors"]
pub const AVColorPrimaries_AVCOL_PRI_EBU3213: AVColorPrimaries = 22;
pub const AVColorPrimaries_AVCOL_PRI_JEDEC_P22: AVColorPrimaries = 22;
#[doc = "< Not part of ABI"]
pub const AVColorPrimaries_AVCOL_PRI_NB: AVColorPrimaries = 23;
#[doc = " Chromaticity coordinates of the source primaries."]
#[doc = " These values match the ones defined by ISO/IEC 23001-8_2013  7.1."]
pub type AVColorPrimaries = ::std::os::raw::c_uint;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED0: AVColorTransferCharacteristic = 0;
#[doc = "< also ITU-R BT1361"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT709: AVColorTransferCharacteristic = 1;
pub const AVColorTransferCharacteristic_AVCOL_TRC_UNSPECIFIED: AVColorTransferCharacteristic = 2;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED: AVColorTransferCharacteristic = 3;
#[doc = "< also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA22: AVColorTransferCharacteristic = 4;
#[doc = "< also ITU-R BT470BG"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA28: AVColorTransferCharacteristic = 5;
#[doc = "< also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE170M: AVColorTransferCharacteristic = 6;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE240M: AVColorTransferCharacteristic = 7;
#[doc = "< \"Linear transfer characteristics\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_LINEAR: AVColorTransferCharacteristic = 8;
#[doc = "< \"Logarithmic transfer characteristic (100:1 range)\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG: AVColorTransferCharacteristic = 9;
#[doc = "< \"Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG_SQRT: AVColorTransferCharacteristic = 10;
#[doc = "< IEC 61966-2-4"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_4: AVColorTransferCharacteristic = 11;
#[doc = "< ITU-R BT1361 Extended Colour Gamut"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT1361_ECG: AVColorTransferCharacteristic = 12;
#[doc = "< IEC 61966-2-1 (sRGB or sYCC)"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_1: AVColorTransferCharacteristic = 13;
#[doc = "< ITU-R BT2020 for 10-bit system"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_10: AVColorTransferCharacteristic = 14;
#[doc = "< ITU-R BT2020 for 12-bit system"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_12: AVColorTransferCharacteristic = 15;
#[doc = "< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE2084: AVColorTransferCharacteristic = 16;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic = 16;
#[doc = "< SMPTE ST 428-1"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE428: AVColorTransferCharacteristic = 17;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic = 17;
#[doc = "< ARIB STD-B67, known as \"Hybrid log-gamma\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_ARIB_STD_B67: AVColorTransferCharacteristic = 18;
#[doc = "< Not part of ABI"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_NB: AVColorTransferCharacteristic = 19;
#[doc = " Color Transfer Characteristic."]
#[doc = " These values match the ones defined by ISO/IEC 23001-8_2013  7.2."]
pub type AVColorTransferCharacteristic = ::std::os::raw::c_uint;
#[doc = "< order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB)"]
pub const AVColorSpace_AVCOL_SPC_RGB: AVColorSpace = 0;
#[doc = "< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B"]
pub const AVColorSpace_AVCOL_SPC_BT709: AVColorSpace = 1;
pub const AVColorSpace_AVCOL_SPC_UNSPECIFIED: AVColorSpace = 2;
pub const AVColorSpace_AVCOL_SPC_RESERVED: AVColorSpace = 3;
#[doc = "< FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
pub const AVColorSpace_AVCOL_SPC_FCC: AVColorSpace = 4;
#[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601"]
pub const AVColorSpace_AVCOL_SPC_BT470BG: AVColorSpace = 5;
#[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC"]
pub const AVColorSpace_AVCOL_SPC_SMPTE170M: AVColorSpace = 6;
#[doc = "< functionally identical to above"]
pub const AVColorSpace_AVCOL_SPC_SMPTE240M: AVColorSpace = 7;
#[doc = "< Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16"]
pub const AVColorSpace_AVCOL_SPC_YCGCO: AVColorSpace = 8;
pub const AVColorSpace_AVCOL_SPC_YCOCG: AVColorSpace = 8;
#[doc = "< ITU-R BT2020 non-constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_BT2020_NCL: AVColorSpace = 9;
#[doc = "< ITU-R BT2020 constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_BT2020_CL: AVColorSpace = 10;
#[doc = "< SMPTE 2085, Y'D'zD'x"]
pub const AVColorSpace_AVCOL_SPC_SMPTE2085: AVColorSpace = 11;
#[doc = "< Chromaticity-derived non-constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_NCL: AVColorSpace = 12;
#[doc = "< Chromaticity-derived constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_CL: AVColorSpace = 13;
#[doc = "< ITU-R BT.2100-0, ICtCp"]
pub const AVColorSpace_AVCOL_SPC_ICTCP: AVColorSpace = 14;
#[doc = "< Not part of ABI"]
pub const AVColorSpace_AVCOL_SPC_NB: AVColorSpace = 15;
#[doc = " YUV colorspace type."]
#[doc = " These values match the ones defined by ISO/IEC 23001-8_2013  7.3."]
pub type AVColorSpace = ::std::os::raw::c_uint;
pub const AVColorRange_AVCOL_RANGE_UNSPECIFIED: AVColorRange = 0;
#[doc = " Narrow or limited range content."]
#[doc = ""]
#[doc = " - For luminance planes:"]
#[doc = ""]
#[doc = "       (219 * E + 16) * 2^(n-8)"]
#[doc = ""]
#[doc = "   F.ex. the range of 16-235 for 8 bits"]
#[doc = ""]
#[doc = " - For chrominance planes:"]
#[doc = ""]
#[doc = "       (224 * E + 128) * 2^(n-8)"]
#[doc = ""]
#[doc = "   F.ex. the range of 16-240 for 8 bits"]
pub const AVColorRange_AVCOL_RANGE_MPEG: AVColorRange = 1;
#[doc = " Full range content."]
#[doc = ""]
#[doc = " - For RGB and luminance planes:"]
#[doc = ""]
#[doc = "       (2^n - 1) * E"]
#[doc = ""]
#[doc = "   F.ex. the range of 0-255 for 8 bits"]
#[doc = ""]
#[doc = " - For chrominance planes:"]
#[doc = ""]
#[doc = "       (2^n - 1) * E + 2^(n - 1)"]
#[doc = ""]
#[doc = "   F.ex. the range of 1-255 for 8 bits"]
pub const AVColorRange_AVCOL_RANGE_JPEG: AVColorRange = 2;
#[doc = "< Not part of ABI"]
pub const AVColorRange_AVCOL_RANGE_NB: AVColorRange = 3;
#[doc = " Visual content value range."]
#[doc = ""]
#[doc = " These values are based on definitions that can be found in multiple"]
#[doc = " specifications, such as ITU-T BT.709 (3.4 - Quantization of RGB, luminance"]
#[doc = " and colour-difference signals), ITU-T BT.2020 (Table 5 - Digital"]
#[doc = " Representation) as well as ITU-T BT.2100 (Table 9 - Digital 10- and 12-bit"]
#[doc = " integer representation). At the time of writing, the BT.2100 one is"]
#[doc = " recommended, as it also defines the full range representation."]
#[doc = ""]
#[doc = " Common definitions:"]
#[doc = "   - For RGB and luminance planes such as Y in YCbCr and I in ICtCp,"]
#[doc = "     'E' is the original value in range of 0.0 to 1.0."]
#[doc = "   - For chrominance planes such as Cb,Cr and Ct,Cp, 'E' is the original"]
#[doc = "     value in range of -0.5 to 0.5."]
#[doc = "   - 'n' is the output bit depth."]
#[doc = "   - For additional definitions such as rounding and clipping to valid n"]
#[doc = "     bit unsigned integer range, please refer to BT.2100 (Table 9)."]
pub type AVColorRange = ::std::os::raw::c_uint;
pub const AVChromaLocation_AVCHROMA_LOC_UNSPECIFIED: AVChromaLocation = 0;
#[doc = "< MPEG-2/4 4:2:0, H.264 default for 4:2:0"]
pub const AVChromaLocation_AVCHROMA_LOC_LEFT: AVChromaLocation = 1;
#[doc = "< MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0"]
pub const AVChromaLocation_AVCHROMA_LOC_CENTER: AVChromaLocation = 2;
#[doc = "< ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2"]
pub const AVChromaLocation_AVCHROMA_LOC_TOPLEFT: AVChromaLocation = 3;
pub const AVChromaLocation_AVCHROMA_LOC_TOP: AVChromaLocation = 4;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOMLEFT: AVChromaLocation = 5;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOM: AVChromaLocation = 6;
#[doc = "< Not part of ABI"]
pub const AVChromaLocation_AVCHROMA_LOC_NB: AVChromaLocation = 7;
#[doc = " Location of chroma samples."]
#[doc = ""]
#[doc = " Illustration showing the location of the first (top left) chroma sample of the"]
#[doc = " image, the left shows only luma, the right"]
#[doc = " shows the location of the chroma sample, the 2 could be imagined to overlay"]
#[doc = " each other but are drawn separately due to limitations of ASCII"]
#[doc = ""]
#[doc = "                1st 2nd       1st 2nd horizontal luma sample positions"]
#[doc = "                 v   v         v   v"]
#[doc = "                 ______        ______"]
#[doc = "1st luma line > |X   X ...    |3 4 X ...     X are luma samples,"]
#[doc = "                |             |1 2           1-6 are possible chroma positions"]
#[doc = "2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position"]
pub type AVChromaLocation = ::std::os::raw::c_uint;
extern "C" {
  #[doc = " Compute the length of an integer list."]
  #[doc = ""]
  #[doc = " @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)"]
  #[doc = " @param term    list terminator (usually 0 or -1)"]
  #[doc = " @param list    pointer to the list"]
  #[doc = " @return  length of the list, in elements, not counting the terminator"]
  pub fn av_int_list_length_for_size(
    elsize: ::std::os::raw::c_uint,
    list: *const ::std::os::raw::c_void,
    term: u64,
  ) -> ::std::os::raw::c_uint;
}
extern "C" {
  #[doc = " Open a file using a UTF-8 filename."]
  #[doc = " The API of this function matches POSIX fopen(), errors are returned through"]
  #[doc = " errno."]
  pub fn av_fopen_utf8(
    path: *const ::std::os::raw::c_char,
    mode: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
extern "C" {
  #[doc = " Return the fractional representation of the internal time base."]
  pub fn av_get_time_base_q() -> AVRational;
}
extern "C" {
  #[doc = " Fill the provided buffer with a string containing a FourCC (four-character"]
  #[doc = " code) representation."]
  #[doc = ""]
  #[doc = " @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE"]
  #[doc = " @param fourcc the fourcc to represent"]
  #[doc = " @return the buffer in input"]
  pub fn av_fourcc_make_string(
    buf: *mut ::std::os::raw::c_char,
    fourcc: u32,
  ) -> *mut ::std::os::raw::c_char;
}
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_NONE: AVMatrixEncoding = 0;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBY: AVMatrixEncoding = 1;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLII: AVMatrixEncoding = 2;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLIIX: AVMatrixEncoding = 3;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DPLIIZ: AVMatrixEncoding = 4;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBYEX: AVMatrixEncoding = 5;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_DOLBYHEADPHONE: AVMatrixEncoding = 6;
pub const AVMatrixEncoding_AV_MATRIX_ENCODING_NB: AVMatrixEncoding = 7;
pub type AVMatrixEncoding = ::std::os::raw::c_uint;
extern "C" {
  #[doc = " Return a channel layout id that matches name, or 0 if no match is found."]
  #[doc = ""]
  #[doc = " name can be one or several of the following notations,"]
  #[doc = " separated by '+' or '|':"]
  #[doc = " - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,"]
  #[doc = "   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);"]
  #[doc = " - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,"]
  #[doc = "   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);"]
  #[doc = " - a number of channels, in decimal, followed by 'c', yielding"]
  #[doc = "   the default channel layout for that number of channels (@see"]
  #[doc = "   av_get_default_channel_layout);"]
  #[doc = " - a channel layout mask, in hexadecimal starting with \"0x\" (see the"]
  #[doc = "   AV_CH_* macros)."]
  #[doc = ""]
  #[doc = " Example: \"stereo+FC\" = \"2c+FC\" = \"2c+1c\" = \"0x7\""]
  pub fn av_get_channel_layout(name: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
  #[doc = " Return a channel layout and the number of channels based on the specified name."]
  #[doc = ""]
  #[doc = " This function is similar to (@see av_get_channel_layout), but can also parse"]
  #[doc = " unknown channel layout specifications."]
  #[doc = ""]
  #[doc = " @param[in]  name             channel layout specification string"]
  #[doc = " @param[out] channel_layout   parsed channel layout (0 if unknown)"]
  #[doc = " @param[out] nb_channels      number of channels"]
  #[doc = ""]
  #[doc = " @return 0 on success, AVERROR(EINVAL) if the parsing fails."]
  pub fn av_get_extended_channel_layout(
    name: *const ::std::os::raw::c_char,
    channel_layout: *mut u64,
    nb_channels: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Return a description of a channel layout."]
  #[doc = " If nb_channels is <= 0, it is guessed from the channel_layout."]
  #[doc = ""]
  #[doc = " @param buf put here the string containing the channel layout"]
  #[doc = " @param buf_size size in bytes of the buffer"]
  pub fn av_get_channel_layout_string(
    buf: *mut ::std::os::raw::c_char,
    buf_size: ::std::os::raw::c_int,
    nb_channels: ::std::os::raw::c_int,
    channel_layout: u64,
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBPrint {
  _unused: [u8; 0],
}
extern "C" {
  #[doc = " Append a description of a channel layout to a bprint buffer."]
  pub fn av_bprint_channel_layout(
    bp: *mut AVBPrint,
    nb_channels: ::std::os::raw::c_int,
    channel_layout: u64,
  );
}
extern "C" {
  #[doc = " Return the number of channels in the channel layout."]
  pub fn av_get_channel_layout_nb_channels(channel_layout: u64) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Return default channel layout for a given number of channels."]
  pub fn av_get_default_channel_layout(nb_channels: ::std::os::raw::c_int) -> i64;
}
extern "C" {
  #[doc = " Get the index of a channel in channel_layout."]
  #[doc = ""]
  #[doc = " @param channel a channel layout describing exactly one channel which must be"]
  #[doc = "                present in channel_layout."]
  #[doc = ""]
  #[doc = " @return index of channel in channel_layout on success, a negative AVERROR"]
  #[doc = "         on error."]
  pub fn av_get_channel_layout_channel_index(
    channel_layout: u64,
    channel: u64,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Get the channel with the given index in channel_layout."]
  pub fn av_channel_layout_extract_channel(
    channel_layout: u64,
    index: ::std::os::raw::c_int,
  ) -> u64;
}
extern "C" {
  #[doc = " Get the name of a given channel."]
  #[doc = ""]
  #[doc = " @return channel name on success, NULL on error."]
  pub fn av_get_channel_name(channel: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Get the description of a given channel."]
  #[doc = ""]
  #[doc = " @param channel  a channel layout with a single channel"]
  #[doc = " @return  channel description on success, NULL on error"]
  pub fn av_get_channel_description(channel: u64) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Get the value and name of a standard channel layout."]
  #[doc = ""]
  #[doc = " @param[in]  index   index in an internal list, starting at 0"]
  #[doc = " @param[out] layout  channel layout mask"]
  #[doc = " @param[out] name    name of the layout"]
  #[doc = " @return  0  if the layout exists,"]
  #[doc = "          <0 if index is beyond the limits"]
  pub fn av_get_standard_channel_layout(
    index: ::std::os::raw::c_uint,
    layout: *mut u64,
    name: *mut *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBuffer {
  _unused: [u8; 0],
}
#[doc = " A reference to a data buffer."]
#[doc = ""]
#[doc = " The size of this struct is not a part of the public ABI and it is not meant"]
#[doc = " to be allocated directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferRef {
  pub buffer: *mut AVBuffer,
  #[doc = " The data buffer. It is considered writable if and only if"]
  #[doc = " this is the only reference to the buffer, in which case"]
  #[doc = " av_buffer_is_writable() returns 1."]
  pub data: *mut u8,
  pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AVBufferRef() {
  assert_eq!(
    ::std::mem::size_of::<AVBufferRef>(),
    24usize,
    concat!("Size of: ", stringify!(AVBufferRef))
  );
  assert_eq!(
    ::std::mem::align_of::<AVBufferRef>(),
    8usize,
    concat!("Alignment of ", stringify!(AVBufferRef))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVBufferRef>())).buffer as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(AVBufferRef),
      "::",
      stringify!(buffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVBufferRef>())).data as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(AVBufferRef),
      "::",
      stringify!(data)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVBufferRef>())).size as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(AVBufferRef),
      "::",
      stringify!(size)
    )
  );
}
extern "C" {
  pub fn av_buffer_alloc(size: ::std::os::raw::c_int) -> *mut AVBufferRef;
}
extern "C" {
  pub fn av_buffer_allocz(size: ::std::os::raw::c_int) -> *mut AVBufferRef;
}
extern "C" {
  pub fn av_buffer_create(
    data: *mut u8,
    size: ::std::os::raw::c_int,
    free: ::std::option::Option<
      unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, data: *mut u8),
    >,
    opaque: *mut ::std::os::raw::c_void,
    flags: ::std::os::raw::c_int,
  ) -> *mut AVBufferRef;
}
extern "C" {
  #[doc = " Default free callback, which calls av_free() on the buffer data."]
  #[doc = " This function is meant to be passed to av_buffer_create(), not called"]
  #[doc = " directly."]
  pub fn av_buffer_default_free(opaque: *mut ::std::os::raw::c_void, data: *mut u8);
}
extern "C" {
  #[doc = " Create a new reference to an AVBuffer."]
  #[doc = ""]
  #[doc = " @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on"]
  #[doc = " failure."]
  pub fn av_buffer_ref(buf: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
  #[doc = " Free a given reference and automatically free the buffer if there are no more"]
  #[doc = " references to it."]
  #[doc = ""]
  #[doc = " @param buf the reference to be freed. The pointer is set to NULL on return."]
  pub fn av_buffer_unref(buf: *mut *mut AVBufferRef);
}
extern "C" {
  #[doc = " @return 1 if the caller may write to the data referred to by buf (which is"]
  #[doc = " true if and only if buf is the only reference to the underlying AVBuffer)."]
  #[doc = " Return 0 otherwise."]
  #[doc = " A positive answer is valid until av_buffer_ref() is called on buf."]
  pub fn av_buffer_is_writable(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " @return the opaque parameter set by av_buffer_create."]
  pub fn av_buffer_get_opaque(buf: *const AVBufferRef) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn av_buffer_get_ref_count(buf: *const AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Create a writable reference from a given buffer reference, avoiding data copy"]
  #[doc = " if possible."]
  #[doc = ""]
  #[doc = " @param buf buffer reference to make writable. On success, buf is either left"]
  #[doc = "            untouched, or it is unreferenced and a new writable AVBufferRef is"]
  #[doc = "            written in its place. On failure, buf is left untouched."]
  #[doc = " @return 0 on success, a negative AVERROR on failure."]
  pub fn av_buffer_make_writable(buf: *mut *mut AVBufferRef) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn av_buffer_realloc(
    buf: *mut *mut AVBufferRef,
    size: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Ensure dst refers to the same data as src."]
  #[doc = ""]
  #[doc = " When *dst is already equivalent to src, do nothing. Otherwise unreference dst"]
  #[doc = " and replace it with a new reference to src."]
  #[doc = ""]
  #[doc = " @param dst Pointer to either a valid buffer reference or NULL. On success,"]
  #[doc = "            this will point to a buffer reference equivalent to src. On"]
  #[doc = "            failure, dst will be left untouched."]
  #[doc = " @param src A buffer reference to replace dst with. May be NULL, then this"]
  #[doc = "            function is equivalent to av_buffer_unref(dst)."]
  #[doc = " @return 0 on success"]
  #[doc = "         AVERROR(ENOMEM) on memory allocation failure."]
  pub fn av_buffer_replace(
    dst: *mut *mut AVBufferRef,
    src: *mut AVBufferRef,
  ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferPool {
  _unused: [u8; 0],
}
extern "C" {
  pub fn av_buffer_pool_init(
    size: ::std::os::raw::c_int,
    alloc: ::std::option::Option<
      unsafe extern "C" fn(size: ::std::os::raw::c_int) -> *mut AVBufferRef,
    >,
  ) -> *mut AVBufferPool;
}
extern "C" {
  pub fn av_buffer_pool_init2(
    size: ::std::os::raw::c_int,
    opaque: *mut ::std::os::raw::c_void,
    alloc: ::std::option::Option<
      unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
      ) -> *mut AVBufferRef,
    >,
    pool_free: ::std::option::Option<unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void)>,
  ) -> *mut AVBufferPool;
}
extern "C" {
  #[doc = " Mark the pool as being available for freeing. It will actually be freed only"]
  #[doc = " once all the allocated buffers associated with the pool are released. Thus it"]
  #[doc = " is safe to call this function while some of the allocated buffers are still"]
  #[doc = " in use."]
  #[doc = ""]
  #[doc = " @param pool pointer to the pool to be freed. It will be set to NULL."]
  pub fn av_buffer_pool_uninit(pool: *mut *mut AVBufferPool);
}
extern "C" {
  #[doc = " Allocate a new AVBuffer, reusing an old buffer from the pool when available."]
  #[doc = " This function may be called simultaneously from multiple threads."]
  #[doc = ""]
  #[doc = " @return a reference to the new buffer on success, NULL on error."]
  pub fn av_buffer_pool_get(pool: *mut AVBufferPool) -> *mut AVBufferRef;
}
extern "C" {
  #[doc = " Query the original opaque parameter of an allocated buffer in the pool."]
  #[doc = ""]
  #[doc = " @param ref a buffer reference to a buffer returned by av_buffer_pool_get."]
  #[doc = " @return the opaque parameter set by the buffer allocator function of the"]
  #[doc = "         buffer pool."]
  #[doc = ""]
  #[doc = " @note the opaque parameter of ref is used by the buffer pool implementation,"]
  #[doc = " therefore you have to use this function to access the original opaque"]
  #[doc = " parameter of an allocated buffer."]
  pub fn av_buffer_pool_buffer_get_opaque(ref_: *mut AVBufferRef) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionaryEntry {
  pub key: *mut ::std::os::raw::c_char,
  pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AVDictionaryEntry() {
  assert_eq!(
    ::std::mem::size_of::<AVDictionaryEntry>(),
    16usize,
    concat!("Size of: ", stringify!(AVDictionaryEntry))
  );
  assert_eq!(
    ::std::mem::align_of::<AVDictionaryEntry>(),
    8usize,
    concat!("Alignment of ", stringify!(AVDictionaryEntry))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVDictionaryEntry>())).key as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(AVDictionaryEntry),
      "::",
      stringify!(key)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVDictionaryEntry>())).value as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(AVDictionaryEntry),
      "::",
      stringify!(value)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionary {
  _unused: [u8; 0],
}
extern "C" {
  #[doc = " Get a dictionary entry with matching key."]
  #[doc = ""]
  #[doc = " The returned entry key or value must not be changed, or it will"]
  #[doc = " cause undefined behavior."]
  #[doc = ""]
  #[doc = " To iterate through all the dictionary entries, you can set the matching key"]
  #[doc = " to the null string \"\" and set the AV_DICT_IGNORE_SUFFIX flag."]
  #[doc = ""]
  #[doc = " @param prev Set to the previous matching element to find the next."]
  #[doc = "             If set to NULL the first matching element is returned."]
  #[doc = " @param key matching key"]
  #[doc = " @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved"]
  #[doc = " @return found entry or NULL in case no matching entry was found in the dictionary"]
  pub fn av_dict_get(
    m: *const AVDictionary,
    key: *const ::std::os::raw::c_char,
    prev: *const AVDictionaryEntry,
    flags: ::std::os::raw::c_int,
  ) -> *mut AVDictionaryEntry;
}
extern "C" {
  #[doc = " Get number of entries in dictionary."]
  #[doc = ""]
  #[doc = " @param m dictionary"]
  #[doc = " @return  number of entries in dictionary"]
  pub fn av_dict_count(m: *const AVDictionary) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Set the given entry in *pm, overwriting an existing entry."]
  #[doc = ""]
  #[doc = " Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,"]
  #[doc = " these arguments will be freed on error."]
  #[doc = ""]
  #[doc = " Warning: Adding a new entry to a dictionary invalidates all existing entries"]
  #[doc = " previously returned with av_dict_get."]
  #[doc = ""]
  #[doc = " @param pm pointer to a pointer to a dictionary struct. If *pm is NULL"]
  #[doc = " a dictionary struct is allocated and put in *pm."]
  #[doc = " @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)"]
  #[doc = " @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags)."]
  #[doc = "        Passing a NULL value will cause an existing entry to be deleted."]
  #[doc = " @return >= 0 on success otherwise an error code <0"]
  pub fn av_dict_set(
    pm: *mut *mut AVDictionary,
    key: *const ::std::os::raw::c_char,
    value: *const ::std::os::raw::c_char,
    flags: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Convenience wrapper for av_dict_set that converts the value to a string"]
  #[doc = " and stores it."]
  #[doc = ""]
  #[doc = " Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error."]
  pub fn av_dict_set_int(
    pm: *mut *mut AVDictionary,
    key: *const ::std::os::raw::c_char,
    value: i64,
    flags: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Parse the key/value pairs list and add the parsed entries to a dictionary."]
  #[doc = ""]
  #[doc = " In case of failure, all the successfully set entries are stored in"]
  #[doc = " *pm. You may need to manually free the created dictionary."]
  #[doc = ""]
  #[doc = " @param key_val_sep  a 0-terminated list of characters used to separate"]
  #[doc = "                     key from value"]
  #[doc = " @param pairs_sep    a 0-terminated list of characters used to separate"]
  #[doc = "                     two pairs from each other"]
  #[doc = " @param flags        flags to use when adding to dictionary."]
  #[doc = "                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL"]
  #[doc = "                     are ignored since the key/value tokens will always"]
  #[doc = "                     be duplicated."]
  #[doc = " @return             0 on success, negative AVERROR code on failure"]
  pub fn av_dict_parse_string(
    pm: *mut *mut AVDictionary,
    str_: *const ::std::os::raw::c_char,
    key_val_sep: *const ::std::os::raw::c_char,
    pairs_sep: *const ::std::os::raw::c_char,
    flags: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Copy entries from one AVDictionary struct into another."]
  #[doc = " @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,"]
  #[doc = "            this function will allocate a struct for you and put it in *dst"]
  #[doc = " @param src pointer to source AVDictionary struct"]
  #[doc = " @param flags flags to use when setting entries in *dst"]
  #[doc = " @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag"]
  #[doc = " @return 0 on success, negative AVERROR code on failure. If dst was allocated"]
  #[doc = "           by this function, callers should free the associated memory."]
  pub fn av_dict_copy(
    dst: *mut *mut AVDictionary,
    src: *const AVDictionary,
    flags: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Free all the memory allocated for an AVDictionary struct"]
  #[doc = " and all keys and values."]
  pub fn av_dict_free(m: *mut *mut AVDictionary);
}
extern "C" {
  #[doc = " Get dictionary entries as a string."]
  #[doc = ""]
  #[doc = " Create a string containing dictionary's entries."]
  #[doc = " Such string may be passed back to av_dict_parse_string()."]
  #[doc = " @note String is escaped with backslashes ('\\')."]
  #[doc = ""]
  #[doc = " @param[in]  m             dictionary"]
  #[doc = " @param[out] buffer        Pointer to buffer that will be allocated with string containg entries."]
  #[doc = "                           Buffer must be freed by the caller when is no longer needed."]
  #[doc = " @param[in]  key_val_sep   character used to separate key from value"]
  #[doc = " @param[in]  pairs_sep     character used to separate two pairs from each other"]
  #[doc = " @return                   >= 0 on success, negative on error"]
  #[doc = " @warning Separators cannot be neither '\\\\' nor '\\0'. They also cannot be the same."]
  pub fn av_dict_get_string(
    m: *const AVDictionary,
    buffer: *mut *mut ::std::os::raw::c_char,
    key_val_sep: ::std::os::raw::c_char,
    pairs_sep: ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
pub const AVSampleFormat_AV_SAMPLE_FMT_NONE: AVSampleFormat = -1;
#[doc = "< unsigned 8 bits"]
pub const AVSampleFormat_AV_SAMPLE_FMT_U8: AVSampleFormat = 0;
#[doc = "< signed 16 bits"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S16: AVSampleFormat = 1;
#[doc = "< signed 32 bits"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S32: AVSampleFormat = 2;
#[doc = "< float"]
pub const AVSampleFormat_AV_SAMPLE_FMT_FLT: AVSampleFormat = 3;
#[doc = "< double"]
pub const AVSampleFormat_AV_SAMPLE_FMT_DBL: AVSampleFormat = 4;
#[doc = "< unsigned 8 bits, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_U8P: AVSampleFormat = 5;
#[doc = "< signed 16 bits, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S16P: AVSampleFormat = 6;
#[doc = "< signed 32 bits, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S32P: AVSampleFormat = 7;
#[doc = "< float, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_FLTP: AVSampleFormat = 8;
#[doc = "< double, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_DBLP: AVSampleFormat = 9;
#[doc = "< signed 64 bits"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S64: AVSampleFormat = 10;
#[doc = "< signed 64 bits, planar"]
pub const AVSampleFormat_AV_SAMPLE_FMT_S64P: AVSampleFormat = 11;
#[doc = "< Number of sample formats. DO NOT USE if linking dynamically"]
pub const AVSampleFormat_AV_SAMPLE_FMT_NB: AVSampleFormat = 12;
#[doc = " Audio sample formats"]
#[doc = ""]
#[doc = " - The data described by the sample format is always in native-endian order."]
#[doc = "   Sample values can be expressed by native C types, hence the lack of a signed"]
#[doc = "   24-bit sample format even though it is a common raw audio data format."]
#[doc = ""]
#[doc = " - The floating-point formats are based on full volume being in the range"]
#[doc = "   [-1.0, 1.0]. Any values outside this range are beyond full volume level."]
#[doc = ""]
#[doc = " - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg"]
#[doc = "   (such as AVFrame in libavcodec) is as follows:"]
#[doc = ""]
#[doc = " @par"]
#[doc = " For planar sample formats, each audio channel is in a separate data plane,"]
#[doc = " and linesize is the buffer size, in bytes, for a single plane. All data"]
#[doc = " planes must be the same size. For packed sample formats, only the first data"]
#[doc = " plane is used, and samples for each channel are interleaved. In this case,"]
#[doc = " linesize is the buffer size, in bytes, for the 1 plane."]
#[doc = ""]
pub type AVSampleFormat = ::std::os::raw::c_int;
extern "C" {
  #[doc = " Return the name of sample_fmt, or NULL if sample_fmt is not"]
  #[doc = " recognized."]
  pub fn av_get_sample_fmt_name(sample_fmt: AVSampleFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE"]
  #[doc = " on error."]
  pub fn av_get_sample_fmt(name: *const ::std::os::raw::c_char) -> AVSampleFormat;
}
extern "C" {
  #[doc = " Return the planar<->packed alternative form of the given sample format, or"]
  #[doc = " AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the"]
  #[doc = " requested planar/packed format, the format returned is the same as the"]
  #[doc = " input."]
  pub fn av_get_alt_sample_fmt(
    sample_fmt: AVSampleFormat,
    planar: ::std::os::raw::c_int,
  ) -> AVSampleFormat;
}
extern "C" {
  #[doc = " Get the packed alternative form of the given sample format."]
  #[doc = ""]
  #[doc = " If the passed sample_fmt is already in packed format, the format returned is"]
  #[doc = " the same as the input."]
  #[doc = ""]
  #[doc = " @return  the packed alternative form of the given sample format or"]
  #[doc = "AV_SAMPLE_FMT_NONE on error."]
  pub fn av_get_packed_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
  #[doc = " Get the planar alternative form of the given sample format."]
  #[doc = ""]
  #[doc = " If the passed sample_fmt is already in planar format, the format returned is"]
  #[doc = " the same as the input."]
  #[doc = ""]
  #[doc = " @return  the planar alternative form of the given sample format or"]
  #[doc = "AV_SAMPLE_FMT_NONE on error."]
  pub fn av_get_planar_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
  #[doc = " Generate a string corresponding to the sample format with"]
  #[doc = " sample_fmt, or a header if sample_fmt is negative."]
  #[doc = ""]
  #[doc = " @param buf the buffer where to write the string"]
  #[doc = " @param buf_size the size of buf"]
  #[doc = " @param sample_fmt the number of the sample format to print the"]
  #[doc = " corresponding info string, or a negative value to print the"]
  #[doc = " corresponding header."]
  #[doc = " @return the pointer to the filled buffer or NULL if sample_fmt is"]
  #[doc = " unknown or in case of other errors"]
  pub fn av_get_sample_fmt_string(
    buf: *mut ::std::os::raw::c_char,
    buf_size: ::std::os::raw::c_int,
    sample_fmt: AVSampleFormat,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Return number of bytes per sample."]
  #[doc = ""]
  #[doc = " @param sample_fmt the sample format"]
  #[doc = " @return number of bytes per sample or zero if unknown for the given"]
  #[doc = " sample format"]
  pub fn av_get_bytes_per_sample(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Check if the sample format is planar."]
  #[doc = ""]
  #[doc = " @param sample_fmt the sample format to inspect"]
  #[doc = " @return 1 if the sample format is planar, 0 if it is interleaved"]
  pub fn av_sample_fmt_is_planar(sample_fmt: AVSampleFormat) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Get the required buffer size for the given audio parameters."]
  #[doc = ""]
  #[doc = " @param[out] linesize calculated linesize, may be NULL"]
  #[doc = " @param nb_channels   the number of channels"]
  #[doc = " @param nb_samples    the number of samples in a single channel"]
  #[doc = " @param sample_fmt    the sample format"]
  #[doc = " @param align         buffer size alignment (0 = default, 1 = no alignment)"]
  #[doc = " @return              required buffer size, or negative error code on failure"]
  pub fn av_samples_get_buffer_size(
    linesize: *mut ::std::os::raw::c_int,
    nb_channels: ::std::os::raw::c_int,
    nb_samples: ::std::os::raw::c_int,
    sample_fmt: AVSampleFormat,
    align: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Fill plane data pointers and linesize for samples with sample"]
  #[doc = " format sample_fmt."]
  #[doc = ""]
  #[doc = " The audio_data array is filled with the pointers to the samples data planes:"]
  #[doc = " for planar, set the start point of each channel's data within the buffer,"]
  #[doc = " for packed, set the start point of the entire buffer only."]
  #[doc = ""]
  #[doc = " The value pointed to by linesize is set to the aligned size of each"]
  #[doc = " channel's data buffer for planar layout, or to the aligned size of the"]
  #[doc = " buffer for all channels for packed layout."]
  #[doc = ""]
  #[doc = " The buffer in buf must be big enough to contain all the samples"]
  #[doc = " (use av_samples_get_buffer_size() to compute its minimum size),"]
  #[doc = " otherwise the audio_data pointers will point to invalid data."]
  #[doc = ""]
  #[doc = " @see enum AVSampleFormat"]
  #[doc = " The documentation for AVSampleFormat describes the data layout."]
  #[doc = ""]
  #[doc = " @param[out] audio_data  array to be filled with the pointer for each channel"]
  #[doc = " @param[out] linesize    calculated linesize, may be NULL"]
  #[doc = " @param buf              the pointer to a buffer containing the samples"]
  #[doc = " @param nb_channels      the number of channels"]
  #[doc = " @param nb_samples       the number of samples in a single channel"]
  #[doc = " @param sample_fmt       the sample format"]
  #[doc = " @param align            buffer size alignment (0 = default, 1 = no alignment)"]
  #[doc = " @return                 >=0 on success or a negative error code on failure"]
  #[doc = " @todo return minimum size in bytes required for the buffer in case"]
  #[doc = " of success at the next bump"]
  pub fn av_samples_fill_arrays(
    audio_data: *mut *mut u8,
    linesize: *mut ::std::os::raw::c_int,
    buf: *const u8,
    nb_channels: ::std::os::raw::c_int,
    nb_samples: ::std::os::raw::c_int,
    sample_fmt: AVSampleFormat,
    align: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Allocate a samples buffer for nb_samples samples, and fill data pointers and"]
  #[doc = " linesize accordingly."]
  #[doc = " The allocated samples buffer can be freed by using av_freep(&audio_data[0])"]
  #[doc = " Allocated data will be initialized to silence."]
  #[doc = ""]
  #[doc = " @see enum AVSampleFormat"]
  #[doc = " The documentation for AVSampleFormat describes the data layout."]
  #[doc = ""]
  #[doc = " @param[out] audio_data  array to be filled with the pointer for each channel"]
  #[doc = " @param[out] linesize    aligned size for audio buffer(s), may be NULL"]
  #[doc = " @param nb_channels      number of audio channels"]
  #[doc = " @param nb_samples       number of samples per channel"]
  #[doc = " @param align            buffer size alignment (0 = default, 1 = no alignment)"]
  #[doc = " @return                 >=0 on success or a negative error code on failure"]
  #[doc = " @todo return the size of the allocated buffer in case of success at the next bump"]
  #[doc = " @see av_samples_fill_arrays()"]
  #[doc = " @see av_samples_alloc_array_and_samples()"]
  pub fn av_samples_alloc(
    audio_data: *mut *mut u8,
    linesize: *mut ::std::os::raw::c_int,
    nb_channels: ::std::os::raw::c_int,
    nb_samples: ::std::os::raw::c_int,
    sample_fmt: AVSampleFormat,
    align: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Allocate a data pointers array, samples buffer for nb_samples"]
  #[doc = " samples, and fill data pointers and linesize accordingly."]
  #[doc = ""]
  #[doc = " This is the same as av_samples_alloc(), but also allocates the data"]
  #[doc = " pointers array."]
  #[doc = ""]
  #[doc = " @see av_samples_alloc()"]
  pub fn av_samples_alloc_array_and_samples(
    audio_data: *mut *mut *mut u8,
    linesize: *mut ::std::os::raw::c_int,
    nb_channels: ::std::os::raw::c_int,
    nb_samples: ::std::os::raw::c_int,
    sample_fmt: AVSampleFormat,
    align: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Copy samples from src to dst."]
  #[doc = ""]
  #[doc = " @param dst destination array of pointers to data planes"]
  #[doc = " @param src source array of pointers to data planes"]
  #[doc = " @param dst_offset offset in samples at which the data will be written to dst"]
  #[doc = " @param src_offset offset in samples at which the data will be read from src"]
  #[doc = " @param nb_samples number of samples to be copied"]
  #[doc = " @param nb_channels number of audio channels"]
  #[doc = " @param sample_fmt audio sample format"]
  pub fn av_samples_copy(
    dst: *mut *mut u8,
    src: *const *mut u8,
    dst_offset: ::std::os::raw::c_int,
    src_offset: ::std::os::raw::c_int,
    nb_samples: ::std::os::raw::c_int,
    nb_channels: ::std::os::raw::c_int,
    sample_fmt: AVSampleFormat,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Fill an audio buffer with silence."]
  #[doc = ""]
  #[doc = " @param audio_data  array of pointers to data planes"]
  #[doc = " @param offset      offset in samples at which to start filling"]
  #[doc = " @param nb_samples  number of samples to fill"]
  #[doc = " @param nb_channels number of audio channels"]
  #[doc = " @param sample_fmt  audio sample format"]
  pub fn av_samples_set_silence(
    audio_data: *mut *mut u8,
    offset: ::std::os::raw::c_int,
    nb_samples: ::std::os::raw::c_int,
    nb_channels: ::std::os::raw::c_int,
    sample_fmt: AVSampleFormat,
  ) -> ::std::os::raw::c_int;
}
#[doc = " The data is the AVPanScan struct defined in libavcodec."]
pub const AVFrameSideDataType_AV_FRAME_DATA_PANSCAN: AVFrameSideDataType = 0;
#[doc = " ATSC A53 Part 4 Closed Captions."]
#[doc = " A53 CC bitstream is stored as uint8_t in AVFrameSideData.data."]
#[doc = " The number of bytes of CC data is AVFrameSideData.size."]
pub const AVFrameSideDataType_AV_FRAME_DATA_A53_CC: AVFrameSideDataType = 1;
#[doc = " Stereoscopic 3d metadata."]
#[doc = " The data is the AVStereo3D struct defined in libavutil/stereo3d.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_STEREO3D: AVFrameSideDataType = 2;
#[doc = " The data is the AVMatrixEncoding enum defined in libavutil/channel_layout.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_MATRIXENCODING: AVFrameSideDataType = 3;
#[doc = " Metadata relevant to a downmix procedure."]
#[doc = " The data is the AVDownmixInfo struct defined in libavutil/downmix_info.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_DOWNMIX_INFO: AVFrameSideDataType = 4;
#[doc = " ReplayGain information in the form of the AVReplayGain struct."]
pub const AVFrameSideDataType_AV_FRAME_DATA_REPLAYGAIN: AVFrameSideDataType = 5;
#[doc = " This side data contains a 3x3 transformation matrix describing an affine"]
#[doc = " transformation that needs to be applied to the frame for correct"]
#[doc = " presentation."]
#[doc = ""]
#[doc = " See libavutil/display.h for a detailed description of the data."]
pub const AVFrameSideDataType_AV_FRAME_DATA_DISPLAYMATRIX: AVFrameSideDataType = 6;
#[doc = " Active Format Description data consisting of a single byte as specified"]
#[doc = " in ETSI TS 101 154 using AVActiveFormatDescription enum."]
pub const AVFrameSideDataType_AV_FRAME_DATA_AFD: AVFrameSideDataType = 7;
#[doc = " Motion vectors exported by some codecs (on demand through the export_mvs"]
#[doc = " flag set in the libavcodec AVCodecContext flags2 option)."]
#[doc = " The data is the AVMotionVector struct defined in"]
#[doc = " libavutil/motion_vector.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_MOTION_VECTORS: AVFrameSideDataType = 8;
#[doc = " Recommmends skipping the specified number of samples. This is exported"]
#[doc = " only if the \"skip_manual\" AVOption is set in libavcodec."]
#[doc = " This has the same format as AV_PKT_DATA_SKIP_SAMPLES."]
#[doc = " @code"]
#[doc = " u32le number of samples to skip from start of this packet"]
#[doc = " u32le number of samples to skip from end of this packet"]
#[doc = " u8    reason for start skip"]
#[doc = " u8    reason for end   skip (0=padding silence, 1=convergence)"]
#[doc = " @endcode"]
pub const AVFrameSideDataType_AV_FRAME_DATA_SKIP_SAMPLES: AVFrameSideDataType = 9;
#[doc = " This side data must be associated with an audio frame and corresponds to"]
#[doc = " enum AVAudioServiceType defined in avcodec.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_AUDIO_SERVICE_TYPE: AVFrameSideDataType = 10;
#[doc = " Mastering display metadata associated with a video frame. The payload is"]
#[doc = " an AVMasteringDisplayMetadata type and contains information about the"]
#[doc = " mastering display color volume."]
pub const AVFrameSideDataType_AV_FRAME_DATA_MASTERING_DISPLAY_METADATA: AVFrameSideDataType = 11;
#[doc = " The GOP timecode in 25 bit timecode format. Data format is 64-bit integer."]
#[doc = " This is set on the first frame of a GOP that has a temporal reference of 0."]
pub const AVFrameSideDataType_AV_FRAME_DATA_GOP_TIMECODE: AVFrameSideDataType = 12;
#[doc = " The data represents the AVSphericalMapping structure defined in"]
#[doc = " libavutil/spherical.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_SPHERICAL: AVFrameSideDataType = 13;
#[doc = " Content light level (based on CTA-861.3). This payload contains data in"]
#[doc = " the form of the AVContentLightMetadata struct."]
pub const AVFrameSideDataType_AV_FRAME_DATA_CONTENT_LIGHT_LEVEL: AVFrameSideDataType = 14;
#[doc = " The data contains an ICC profile as an opaque octet buffer following the"]
#[doc = " format described by ISO 15076-1 with an optional name defined in the"]
#[doc = " metadata key entry \"name\"."]
pub const AVFrameSideDataType_AV_FRAME_DATA_ICC_PROFILE: AVFrameSideDataType = 15;
#[doc = " Implementation-specific description of the format of AV_FRAME_QP_TABLE_DATA."]
#[doc = " The contents of this side data are undocumented and internal; use"]
#[doc = " av_frame_set_qp_table() and av_frame_get_qp_table() to access this in a"]
#[doc = " meaningful way instead."]
pub const AVFrameSideDataType_AV_FRAME_DATA_QP_TABLE_PROPERTIES: AVFrameSideDataType = 16;
#[doc = " Raw QP table data. Its format is described by"]
#[doc = " AV_FRAME_DATA_QP_TABLE_PROPERTIES. Use av_frame_set_qp_table() and"]
#[doc = " av_frame_get_qp_table() to access this instead."]
pub const AVFrameSideDataType_AV_FRAME_DATA_QP_TABLE_DATA: AVFrameSideDataType = 17;
#[doc = " Timecode which conforms to SMPTE ST 12-1. The data is an array of 4 uint32_t"]
#[doc = " where the first uint32_t describes how many (1-3) of the other timecodes are used."]
#[doc = " The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()"]
#[doc = " function in libavutil/timecode.h."]
pub const AVFrameSideDataType_AV_FRAME_DATA_S12M_TIMECODE: AVFrameSideDataType = 18;
#[doc = " HDR dynamic metadata associated with a video frame. The payload is"]
#[doc = " an AVDynamicHDRPlus type and contains information for color"]
#[doc = " volume transform - application 4 of SMPTE 2094-40:2016 standard."]
pub const AVFrameSideDataType_AV_FRAME_DATA_DYNAMIC_HDR_PLUS: AVFrameSideDataType = 19;
#[doc = " Regions Of Interest, the data is an array of AVRegionOfInterest type, the number of"]
#[doc = " array element is implied by AVFrameSideData.size / AVRegionOfInterest.self_size."]
pub const AVFrameSideDataType_AV_FRAME_DATA_REGIONS_OF_INTEREST: AVFrameSideDataType = 20;
#[doc = " Encoding parameters for a video frame, as described by AVVideoEncParams."]
pub const AVFrameSideDataType_AV_FRAME_DATA_VIDEO_ENC_PARAMS: AVFrameSideDataType = 21;
#[doc = " User data unregistered metadata associated with a video frame."]
#[doc = " This is the H.26[45] UDU SEI message, and shouldn't be used for any other purpose"]
#[doc = " The data is stored as uint8_t in AVFrameSideData.data which is 16 bytes of"]
#[doc = " uuid_iso_iec_11578 followed by AVFrameSideData.size - 16 bytes of user_data_payload_byte."]
pub const AVFrameSideDataType_AV_FRAME_DATA_SEI_UNREGISTERED: AVFrameSideDataType = 22;
#[doc = " Film grain parameters for a frame, described by AVFilmGrainParams."]
#[doc = " Must be present for every frame which should have film grain applied."]
pub const AVFrameSideDataType_AV_FRAME_DATA_FILM_GRAIN_PARAMS: AVFrameSideDataType = 23;
#[doc = " @defgroup lavu_frame AVFrame"]
#[doc = " @ingroup lavu_data"]
#[doc = ""]
#[doc = " @{"]
#[doc = " AVFrame is an abstraction for reference-counted raw multimedia data."]
pub type AVFrameSideDataType = ::std::os::raw::c_uint;
pub const AVActiveFormatDescription_AV_AFD_SAME: AVActiveFormatDescription = 8;
pub const AVActiveFormatDescription_AV_AFD_4_3: AVActiveFormatDescription = 9;
pub const AVActiveFormatDescription_AV_AFD_16_9: AVActiveFormatDescription = 10;
pub const AVActiveFormatDescription_AV_AFD_14_9: AVActiveFormatDescription = 11;
pub const AVActiveFormatDescription_AV_AFD_4_3_SP_14_9: AVActiveFormatDescription = 13;
pub const AVActiveFormatDescription_AV_AFD_16_9_SP_14_9: AVActiveFormatDescription = 14;
pub const AVActiveFormatDescription_AV_AFD_SP_4_3: AVActiveFormatDescription = 15;
pub type AVActiveFormatDescription = ::std::os::raw::c_uint;
#[doc = " Structure to hold side data for an AVFrame."]
#[doc = ""]
#[doc = " sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be added"]
#[doc = " to the end with a minor bump."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFrameSideData {
  pub type_: AVFrameSideDataType,
  pub data: *mut u8,
  pub size: ::std::os::raw::c_int,
  pub metadata: *mut AVDictionary,
  pub buf: *mut AVBufferRef,
}
#[test]
fn bindgen_test_layout_AVFrameSideData() {
  assert_eq!(
    ::std::mem::size_of::<AVFrameSideData>(),
    40usize,
    concat!("Size of: ", stringify!(AVFrameSideData))
  );
  assert_eq!(
    ::std::mem::align_of::<AVFrameSideData>(),
    8usize,
    concat!("Alignment of ", stringify!(AVFrameSideData))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrameSideData),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).data as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrameSideData),
      "::",
      stringify!(data)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).size as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrameSideData),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).metadata as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrameSideData),
      "::",
      stringify!(metadata)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).buf as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrameSideData),
      "::",
      stringify!(buf)
    )
  );
}
#[doc = " Structure describing a single Region Of Interest."]
#[doc = ""]
#[doc = " When multiple regions are defined in a single side-data block, they"]
#[doc = " should be ordered from most to least important - some encoders are only"]
#[doc = " capable of supporting a limited number of distinct regions, so will have"]
#[doc = " to truncate the list."]
#[doc = ""]
#[doc = " When overlapping regions are defined, the first region containing a given"]
#[doc = " area of the frame applies."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRegionOfInterest {
  #[doc = " Must be set to the size of this data structure (that is,"]
  #[doc = " sizeof(AVRegionOfInterest))."]
  pub self_size: u32,
  #[doc = " Distance in pixels from the top edge of the frame to the top and"]
  #[doc = " bottom edges and from the left edge of the frame to the left and"]
  #[doc = " right edges of the rectangle defining this region of interest."]
  #[doc = ""]
  #[doc = " The constraints on a region are encoder dependent, so the region"]
  #[doc = " actually affected may be slightly larger for alignment or other"]
  #[doc = " reasons."]
  pub top: ::std::os::raw::c_int,
  pub bottom: ::std::os::raw::c_int,
  pub left: ::std::os::raw::c_int,
  pub right: ::std::os::raw::c_int,
  #[doc = " Quantisation offset."]
  #[doc = ""]
  #[doc = " Must be in the range -1 to +1.  A value of zero indicates no quality"]
  #[doc = " change.  A negative value asks for better quality (less quantisation),"]
  #[doc = " while a positive value asks for worse quality (greater quantisation)."]
  #[doc = ""]
  #[doc = " The range is calibrated so that the extreme values indicate the"]
  #[doc = " largest possible offset - if the rest of the frame is encoded with the"]
  #[doc = " worst possible quality, an offset of -1 indicates that this region"]
  #[doc = " should be encoded with the best possible quality anyway.  Intermediate"]
  #[doc = " values are then interpolated in some codec-dependent way."]
  #[doc = ""]
  #[doc = " For example, in 10-bit H.264 the quantisation parameter varies between"]
  #[doc = " -12 and 51.  A typical qoffset value of -1/10 therefore indicates that"]
  #[doc = " this region should be encoded with a QP around one-tenth of the full"]
  #[doc = " range better than the rest of the frame.  So, if most of the frame"]
  #[doc = " were to be encoded with a QP of around 30, this region would get a QP"]
  #[doc = " of around 24 (an offset of approximately -1/10 * (51 - -12) = -6.3)."]
  #[doc = " An extreme value of -1 would indicate that this region should be"]
  #[doc = " encoded with the best possible quality regardless of the treatment of"]
  #[doc = " the rest of the frame - that is, should be encoded at a QP of -12."]
  pub qoffset: AVRational,
}
#[test]
fn bindgen_test_layout_AVRegionOfInterest() {
  assert_eq!(
    ::std::mem::size_of::<AVRegionOfInterest>(),
    28usize,
    concat!("Size of: ", stringify!(AVRegionOfInterest))
  );
  assert_eq!(
    ::std::mem::align_of::<AVRegionOfInterest>(),
    4usize,
    concat!("Alignment of ", stringify!(AVRegionOfInterest))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVRegionOfInterest>())).self_size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(AVRegionOfInterest),
      "::",
      stringify!(self_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVRegionOfInterest>())).top as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(AVRegionOfInterest),
      "::",
      stringify!(top)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVRegionOfInterest>())).bottom as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(AVRegionOfInterest),
      "::",
      stringify!(bottom)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVRegionOfInterest>())).left as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(AVRegionOfInterest),
      "::",
      stringify!(left)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVRegionOfInterest>())).right as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(AVRegionOfInterest),
      "::",
      stringify!(right)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVRegionOfInterest>())).qoffset as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(AVRegionOfInterest),
      "::",
      stringify!(qoffset)
    )
  );
}
#[doc = " This structure describes decoded (raw) audio or video data."]
#[doc = ""]
#[doc = " AVFrame must be allocated using av_frame_alloc(). Note that this only"]
#[doc = " allocates the AVFrame itself, the buffers for the data must be managed"]
#[doc = " through other means (see below)."]
#[doc = " AVFrame must be freed with av_frame_free()."]
#[doc = ""]
#[doc = " AVFrame is typically allocated once and then reused multiple times to hold"]
#[doc = " different data (e.g. a single AVFrame to hold frames received from a"]
#[doc = " decoder). In such a case, av_frame_unref() will free any references held by"]
#[doc = " the frame and reset it to its original clean state before it"]
#[doc = " is reused again."]
#[doc = ""]
#[doc = " The data described by an AVFrame is usually reference counted through the"]
#[doc = " AVBuffer API. The underlying buffer references are stored in AVFrame.buf /"]
#[doc = " AVFrame.extended_buf. An AVFrame is considered to be reference counted if at"]
#[doc = " least one reference is set, i.e. if AVFrame.buf[0] != NULL. In such a case,"]
#[doc = " every single data plane must be contained in one of the buffers in"]
#[doc = " AVFrame.buf or AVFrame.extended_buf."]
#[doc = " There may be a single buffer for all the data, or one separate buffer for"]
#[doc = " each plane, or anything in between."]
#[doc = ""]
#[doc = " sizeof(AVFrame) is not a part of the public ABI, so new fields may be added"]
#[doc = " to the end with a minor bump."]
#[doc = ""]
#[doc = " Fields can be accessed through AVOptions, the name string used, matches the"]
#[doc = " C structure field name for fields accessible through AVOptions. The AVClass"]
#[doc = " for AVFrame can be obtained from avcodec_get_frame_class()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFrame {
  #[doc = " pointer to the picture/channel planes."]
  #[doc = " This might be different from the first allocated byte"]
  #[doc = ""]
  #[doc = " Some decoders access areas outside 0,0 - width,height, please"]
  #[doc = " see avcodec_align_dimensions2(). Some filters and swscale can read"]
  #[doc = " up to 16 bytes beyond the planes, if these filters are to be used,"]
  #[doc = " then 16 extra bytes must be allocated."]
  #[doc = ""]
  #[doc = " NOTE: Except for hwaccel formats, pointers not needed by the format"]
  #[doc = " MUST be set to NULL."]
  pub data: [*mut u8; 8usize],
  #[doc = " For video, size in bytes of each picture line."]
  #[doc = " For audio, size in bytes of each plane."]
  #[doc = ""]
  #[doc = " For audio, only linesize[0] may be set. For planar audio, each channel"]
  #[doc = " plane must be the same size."]
  #[doc = ""]
  #[doc = " For video the linesizes should be multiples of the CPUs alignment"]
  #[doc = " preference, this is 16 or 32 for modern desktop CPUs."]
  #[doc = " Some code requires such alignment other code can be slower without"]
  #[doc = " correct alignment, for yet other it makes no difference."]
  #[doc = ""]
  #[doc = " @note The linesize may be larger than the size of usable data -- there"]
  #[doc = " may be extra padding present for performance reasons."]
  pub linesize: [::std::os::raw::c_int; 8usize],
  #[doc = " pointers to the data planes/channels."]
  #[doc = ""]
  #[doc = " For video, this should simply point to data[]."]
  #[doc = ""]
  #[doc = " For planar audio, each channel has a separate data pointer, and"]
  #[doc = " linesize[0] contains the size of each channel buffer."]
  #[doc = " For packed audio, there is just one data pointer, and linesize[0]"]
  #[doc = " contains the total size of the buffer for all channels."]
  #[doc = ""]
  #[doc = " Note: Both data and extended_data should always be set in a valid frame,"]
  #[doc = " but for planar audio with more channels that can fit in data,"]
  #[doc = " extended_data must be used in order to access all channels."]
  pub extended_data: *mut *mut u8,
  #[doc = " @name Video dimensions"]
  #[doc = " Video frames only. The coded dimensions (in pixels) of the video frame,"]
  #[doc = " i.e. the size of the rectangle that contains some well-defined values."]
  #[doc = ""]
  #[doc = " @note The part of the frame intended for display/presentation is further"]
  #[doc = " restricted by the @ref cropping \"Cropping rectangle\"."]
  #[doc = " @{"]
  pub width: ::std::os::raw::c_int,
  #[doc = " @name Video dimensions"]
  #[doc = " Video frames only. The coded dimensions (in pixels) of the video frame,"]
  #[doc = " i.e. the size of the rectangle that contains some well-defined values."]
  #[doc = ""]
  #[doc = " @note The part of the frame intended for display/presentation is further"]
  #[doc = " restricted by the @ref cropping \"Cropping rectangle\"."]
  #[doc = " @{"]
  pub height: ::std::os::raw::c_int,
  #[doc = " number of audio samples (per channel) described by this frame"]
  pub nb_samples: ::std::os::raw::c_int,
  #[doc = " format of the frame, -1 if unknown or unset"]
  #[doc = " Values correspond to enum AVPixelFormat for video frames,"]
  #[doc = " enum AVSampleFormat for audio)"]
  pub format: ::std::os::raw::c_int,
  #[doc = " 1 -> keyframe, 0-> not"]
  pub key_frame: ::std::os::raw::c_int,
  #[doc = " Picture type of the frame."]
  pub pict_type: AVPictureType,
  #[doc = " Sample aspect ratio for the video frame, 0/1 if unknown/unspecified."]
  pub sample_aspect_ratio: AVRational,
  #[doc = " Presentation timestamp in time_base units (time when frame should be shown to user)."]
  pub pts: i64,
  #[doc = " PTS copied from the AVPacket that was decoded to produce this frame."]
  #[doc = " @deprecated use the pts field instead"]
  pub pkt_pts: i64,
  #[doc = " DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)"]
  #[doc = " This is also the Presentation time of this AVFrame calculated from"]
  #[doc = " only AVPacket.dts values without pts values."]
  pub pkt_dts: i64,
  #[doc = " picture number in bitstream order"]
  pub coded_picture_number: ::std::os::raw::c_int,
  #[doc = " picture number in display order"]
  pub display_picture_number: ::std::os::raw::c_int,
  #[doc = " quality (between 1 (good) and FF_LAMBDA_MAX (bad))"]
  pub quality: ::std::os::raw::c_int,
  #[doc = " for some private data of the user"]
  pub opaque: *mut ::std::os::raw::c_void,
  #[doc = " @deprecated unused"]
  pub error: [u64; 8usize],
  #[doc = " When decoding, this signals how much the picture must be delayed."]
  #[doc = " extra_delay = repeat_pict / (2*fps)"]
  pub repeat_pict: ::std::os::raw::c_int,
  #[doc = " The content of the picture is interlaced."]
  pub interlaced_frame: ::std::os::raw::c_int,
  #[doc = " If the content is interlaced, is top field displayed first."]
  pub top_field_first: ::std::os::raw::c_int,
  #[doc = " Tell user application that palette has changed from previous frame."]
  pub palette_has_changed: ::std::os::raw::c_int,
  #[doc = " reordered opaque 64 bits (generally an integer or a double precision float"]
  #[doc = " PTS but can be anything)."]
  #[doc = " The user sets AVCodecContext.reordered_opaque to represent the input at"]
  #[doc = " that time,"]
  #[doc = " the decoder reorders values as needed and sets AVFrame.reordered_opaque"]
  #[doc = " to exactly one of the values provided by the user through AVCodecContext.reordered_opaque"]
  pub reordered_opaque: i64,
  #[doc = " Sample rate of the audio data."]
  pub sample_rate: ::std::os::raw::c_int,
  #[doc = " Channel layout of the audio data."]
  pub channel_layout: u64,
  #[doc = " AVBuffer references backing the data for this frame. If all elements of"]
  #[doc = " this array are NULL, then this frame is not reference counted. This array"]
  #[doc = " must be filled contiguously -- if buf[i] is non-NULL then buf[j] must"]
  #[doc = " also be non-NULL for all j < i."]
  #[doc = ""]
  #[doc = " There may be at most one AVBuffer per data plane, so for video this array"]
  #[doc = " always contains all the references. For planar audio with more than"]
  #[doc = " AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in"]
  #[doc = " this array. Then the extra AVBufferRef pointers are stored in the"]
  #[doc = " extended_buf array."]
  pub buf: [*mut AVBufferRef; 8usize],
  #[doc = " For planar audio which requires more than AV_NUM_DATA_POINTERS"]
  #[doc = " AVBufferRef pointers, this array will hold all the references which"]
  #[doc = " cannot fit into AVFrame.buf."]
  #[doc = ""]
  #[doc = " Note that this is different from AVFrame.extended_data, which always"]
  #[doc = " contains all the pointers. This array only contains the extra pointers,"]
  #[doc = " which cannot fit into AVFrame.buf."]
  #[doc = ""]
  #[doc = " This array is always allocated using av_malloc() by whoever constructs"]
  #[doc = " the frame. It is freed in av_frame_unref()."]
  pub extended_buf: *mut *mut AVBufferRef,
  #[doc = " Number of elements in extended_buf."]
  pub nb_extended_buf: ::std::os::raw::c_int,
  pub side_data: *mut *mut AVFrameSideData,
  pub nb_side_data: ::std::os::raw::c_int,
  #[doc = " Frame flags, a combination of @ref lavu_frame_flags"]
  pub flags: ::std::os::raw::c_int,
  #[doc = " MPEG vs JPEG YUV range."]
  #[doc = " - encoding: Set by user"]
  #[doc = " - decoding: Set by libavcodec"]
  pub color_range: AVColorRange,
  pub color_primaries: AVColorPrimaries,
  pub color_trc: AVColorTransferCharacteristic,
  #[doc = " YUV colorspace type."]
  #[doc = " - encoding: Set by user"]
  #[doc = " - decoding: Set by libavcodec"]
  pub colorspace: AVColorSpace,
  pub chroma_location: AVChromaLocation,
  #[doc = " frame timestamp estimated using various heuristics, in stream time base"]
  #[doc = " - encoding: unused"]
  #[doc = " - decoding: set by libavcodec, read by user."]
  pub best_effort_timestamp: i64,
  #[doc = " reordered pos from the last AVPacket that has been input into the decoder"]
  #[doc = " - encoding: unused"]
  #[doc = " - decoding: Read by user."]
  pub pkt_pos: i64,
  #[doc = " duration of the corresponding packet, expressed in"]
  #[doc = " AVStream->time_base units, 0 if unknown."]
  #[doc = " - encoding: unused"]
  #[doc = " - decoding: Read by user."]
  pub pkt_duration: i64,
  #[doc = " metadata."]
  #[doc = " - encoding: Set by user."]
  #[doc = " - decoding: Set by libavcodec."]
  pub metadata: *mut AVDictionary,
  #[doc = " decode error flags of the frame, set to a combination of"]
  #[doc = " FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there"]
  #[doc = " were errors during the decoding."]
  #[doc = " - encoding: unused"]
  #[doc = " - decoding: set by libavcodec, read by user."]
  pub decode_error_flags: ::std::os::raw::c_int,
  #[doc = " number of audio channels, only used for audio."]
  #[doc = " - encoding: unused"]
  #[doc = " - decoding: Read by user."]
  pub channels: ::std::os::raw::c_int,
  #[doc = " size of the corresponding packet containing the compressed"]
  #[doc = " frame."]
  #[doc = " It is set to a negative value if unknown."]
  #[doc = " - encoding: unused"]
  #[doc = " - decoding: set by libavcodec, read by user."]
  pub pkt_size: ::std::os::raw::c_int,
  #[doc = " QP table"]
  pub qscale_table: *mut i8,
  #[doc = " QP store stride"]
  pub qstride: ::std::os::raw::c_int,
  pub qscale_type: ::std::os::raw::c_int,
  pub qp_table_buf: *mut AVBufferRef,
  #[doc = " For hwaccel-format frames, this should be a reference to the"]
  #[doc = " AVHWFramesContext describing the frame."]
  pub hw_frames_ctx: *mut AVBufferRef,
  #[doc = " AVBufferRef for free use by the API user. FFmpeg will never check the"]
  #[doc = " contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when"]
  #[doc = " the frame is unreferenced. av_frame_copy_props() calls create a new"]
  #[doc = " reference with av_buffer_ref() for the target frame's opaque_ref field."]
  #[doc = ""]
  #[doc = " This is unrelated to the opaque field, although it serves a similar"]
  #[doc = " purpose."]
  pub opaque_ref: *mut AVBufferRef,
  #[doc = " @anchor cropping"]
  #[doc = " @name Cropping"]
  #[doc = " Video frames only. The number of pixels to discard from the the"]
  #[doc = " top/bottom/left/right border of the frame to obtain the sub-rectangle of"]
  #[doc = " the frame intended for presentation."]
  #[doc = " @{"]
  pub crop_top: size_t,
  pub crop_bottom: size_t,
  pub crop_left: size_t,
  pub crop_right: size_t,
  #[doc = " AVBufferRef for internal use by a single libav* library."]
  #[doc = " Must not be used to transfer data between libraries."]
  #[doc = " Has to be NULL when ownership of the frame leaves the respective library."]
  #[doc = ""]
  #[doc = " Code outside the FFmpeg libs should never check or change the contents of the buffer ref."]
  #[doc = ""]
  #[doc = " FFmpeg calls av_buffer_unref() on it when the frame is unreferenced."]
  #[doc = " av_frame_copy_props() calls create a new reference with av_buffer_ref()"]
  #[doc = " for the target frame's private_ref field."]
  pub private_ref: *mut AVBufferRef,
}
#[test]
fn bindgen_test_layout_AVFrame() {
  assert_eq!(
    ::std::mem::size_of::<AVFrame>(),
    536usize,
    concat!("Size of: ", stringify!(AVFrame))
  );
  assert_eq!(
    ::std::mem::align_of::<AVFrame>(),
    8usize,
    concat!("Alignment of ", stringify!(AVFrame))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).data as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(data)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).linesize as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(linesize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).extended_data as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(extended_data)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).width as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(width)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).height as *const _ as usize },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(height)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).nb_samples as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(nb_samples)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).format as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(format)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).key_frame as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(key_frame)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).pict_type as *const _ as usize },
    124usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(pict_type)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).sample_aspect_ratio as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(sample_aspect_ratio)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).pts as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(pts)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_pts as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(pkt_pts)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_dts as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(pkt_dts)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).coded_picture_number as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(coded_picture_number)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).display_picture_number as *const _ as usize },
    164usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(display_picture_number)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).quality as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(quality)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).opaque as *const _ as usize },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(opaque)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).error as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(error)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).repeat_pict as *const _ as usize },
    248usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(repeat_pict)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).interlaced_frame as *const _ as usize },
    252usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(interlaced_frame)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).top_field_first as *const _ as usize },
    256usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(top_field_first)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).palette_has_changed as *const _ as usize },
    260usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(palette_has_changed)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).reordered_opaque as *const _ as usize },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(reordered_opaque)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).sample_rate as *const _ as usize },
    272usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(sample_rate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).channel_layout as *const _ as usize },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(channel_layout)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).buf as *const _ as usize },
    288usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(buf)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).extended_buf as *const _ as usize },
    352usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(extended_buf)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).nb_extended_buf as *const _ as usize },
    360usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(nb_extended_buf)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).side_data as *const _ as usize },
    368usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(side_data)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).nb_side_data as *const _ as usize },
    376usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(nb_side_data)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).flags as *const _ as usize },
    380usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).color_range as *const _ as usize },
    384usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(color_range)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).color_primaries as *const _ as usize },
    388usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(color_primaries)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).color_trc as *const _ as usize },
    392usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(color_trc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).colorspace as *const _ as usize },
    396usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(colorspace)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).chroma_location as *const _ as usize },
    400usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(chroma_location)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).best_effort_timestamp as *const _ as usize },
    408usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(best_effort_timestamp)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_pos as *const _ as usize },
    416usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(pkt_pos)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_duration as *const _ as usize },
    424usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(pkt_duration)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).metadata as *const _ as usize },
    432usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(metadata)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).decode_error_flags as *const _ as usize },
    440usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(decode_error_flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).channels as *const _ as usize },
    444usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(channels)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_size as *const _ as usize },
    448usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(pkt_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).qscale_table as *const _ as usize },
    456usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(qscale_table)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).qstride as *const _ as usize },
    464usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(qstride)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).qscale_type as *const _ as usize },
    468usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(qscale_type)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).qp_table_buf as *const _ as usize },
    472usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(qp_table_buf)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).hw_frames_ctx as *const _ as usize },
    480usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(hw_frames_ctx)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).opaque_ref as *const _ as usize },
    488usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(opaque_ref)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_top as *const _ as usize },
    496usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(crop_top)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_bottom as *const _ as usize },
    504usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(crop_bottom)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_left as *const _ as usize },
    512usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(crop_left)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_right as *const _ as usize },
    520usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(crop_right)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<AVFrame>())).private_ref as *const _ as usize },
    528usize,
    concat!(
      "Offset of field: ",
      stringify!(AVFrame),
      "::",
      stringify!(private_ref)
    )
  );
}
extern "C" {
  #[doc = " Accessors for some AVFrame fields. These used to be provided for ABI"]
  #[doc = " compatibility, and do not need to be used anymore."]
  pub fn av_frame_get_best_effort_timestamp(frame: *const AVFrame) -> i64;
}
extern "C" {
  pub fn av_frame_set_best_effort_timestamp(frame: *mut AVFrame, val: i64);
}
extern "C" {
  pub fn av_frame_get_pkt_duration(frame: *const AVFrame) -> i64;
}
extern "C" {
  pub fn av_frame_set_pkt_duration(frame: *mut AVFrame, val: i64);
}
extern "C" {
  pub fn av_frame_get_pkt_pos(frame: *const AVFrame) -> i64;
}
extern "C" {
  pub fn av_frame_set_pkt_pos(frame: *mut AVFrame, val: i64);
}
extern "C" {
  pub fn av_frame_get_channel_layout(frame: *const AVFrame) -> i64;
}
extern "C" {
  pub fn av_frame_set_channel_layout(frame: *mut AVFrame, val: i64);
}
extern "C" {
  pub fn av_frame_get_channels(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn av_frame_set_channels(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
  pub fn av_frame_get_sample_rate(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn av_frame_set_sample_rate(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
  pub fn av_frame_get_metadata(frame: *const AVFrame) -> *mut AVDictionary;
}
extern "C" {
  pub fn av_frame_set_metadata(frame: *mut AVFrame, val: *mut AVDictionary);
}
extern "C" {
  pub fn av_frame_get_decode_error_flags(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn av_frame_set_decode_error_flags(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
  pub fn av_frame_get_pkt_size(frame: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn av_frame_set_pkt_size(frame: *mut AVFrame, val: ::std::os::raw::c_int);
}
extern "C" {
  pub fn av_frame_get_qp_table(
    f: *mut AVFrame,
    stride: *mut ::std::os::raw::c_int,
    type_: *mut ::std::os::raw::c_int,
  ) -> *mut i8;
}
extern "C" {
  pub fn av_frame_set_qp_table(
    f: *mut AVFrame,
    buf: *mut AVBufferRef,
    stride: ::std::os::raw::c_int,
    type_: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn av_frame_get_colorspace(frame: *const AVFrame) -> AVColorSpace;
}
extern "C" {
  pub fn av_frame_set_colorspace(frame: *mut AVFrame, val: AVColorSpace);
}
extern "C" {
  pub fn av_frame_get_color_range(frame: *const AVFrame) -> AVColorRange;
}
extern "C" {
  pub fn av_frame_set_color_range(frame: *mut AVFrame, val: AVColorRange);
}
extern "C" {
  #[doc = " Get the name of a colorspace."]
  #[doc = " @return a static string identifying the colorspace; can be NULL."]
  pub fn av_get_colorspace_name(val: AVColorSpace) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Allocate an AVFrame and set its fields to default values.  The resulting"]
  #[doc = " struct must be freed using av_frame_free()."]
  #[doc = ""]
  #[doc = " @return An AVFrame filled with default values or NULL on failure."]
  #[doc = ""]
  #[doc = " @note this only allocates the AVFrame itself, not the data buffers. Those"]
  #[doc = " must be allocated through other means, e.g. with av_frame_get_buffer() or"]
  #[doc = " manually."]
  pub fn av_frame_alloc() -> *mut AVFrame;
}
extern "C" {
  #[doc = " Free the frame and any dynamically allocated objects in it,"]
  #[doc = " e.g. extended_data. If the frame is reference counted, it will be"]
  #[doc = " unreferenced first."]
  #[doc = ""]
  #[doc = " @param frame frame to be freed. The pointer will be set to NULL."]
  pub fn av_frame_free(frame: *mut *mut AVFrame);
}
extern "C" {
  #[doc = " Set up a new reference to the data described by the source frame."]
  #[doc = ""]
  #[doc = " Copy frame properties from src to dst and create a new reference for each"]
  #[doc = " AVBufferRef from src."]
  #[doc = ""]
  #[doc = " If src is not reference counted, new buffers are allocated and the data is"]
  #[doc = " copied."]
  #[doc = ""]
  #[doc = " @warning: dst MUST have been either unreferenced with av_frame_unref(dst),"]
  #[doc = "           or newly allocated with av_frame_alloc() before calling this"]
  #[doc = "           function, or undefined behavior will occur."]
  #[doc = ""]
  #[doc = " @return 0 on success, a negative AVERROR on error"]
  pub fn av_frame_ref(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Create a new frame that references the same data as src."]
  #[doc = ""]
  #[doc = " This is a shortcut for av_frame_alloc()+av_frame_ref()."]
  #[doc = ""]
  #[doc = " @return newly created AVFrame on success, NULL on error."]
  pub fn av_frame_clone(src: *const AVFrame) -> *mut AVFrame;
}
extern "C" {
  #[doc = " Unreference all the buffers referenced by frame and reset the frame fields."]
  pub fn av_frame_unref(frame: *mut AVFrame);
}
extern "C" {
  #[doc = " Move everything contained in src to dst and reset src."]
  #[doc = ""]
  #[doc = " @warning: dst is not unreferenced, but directly overwritten without reading"]
  #[doc = "           or deallocating its contents. Call av_frame_unref(dst) manually"]
  #[doc = "           before calling this function to ensure that no memory is leaked."]
  pub fn av_frame_move_ref(dst: *mut AVFrame, src: *mut AVFrame);
}
extern "C" {
  #[doc = " Allocate new buffer(s) for audio or video data."]
  #[doc = ""]
  #[doc = " The following fields must be set on frame before calling this function:"]
  #[doc = " - format (pixel format for video, sample format for audio)"]
  #[doc = " - width and height for video"]
  #[doc = " - nb_samples and channel_layout for audio"]
  #[doc = ""]
  #[doc = " This function will fill AVFrame.data and AVFrame.buf arrays and, if"]
  #[doc = " necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf."]
  #[doc = " For planar formats, one buffer will be allocated for each plane."]
  #[doc = ""]
  #[doc = " @warning: if frame already has been allocated, calling this function will"]
  #[doc = "           leak memory. In addition, undefined behavior can occur in certain"]
  #[doc = "           cases."]
  #[doc = ""]
  #[doc = " @param frame frame in which to store the new buffers."]
  #[doc = " @param align Required buffer size alignment. If equal to 0, alignment will be"]
  #[doc = "              chosen automatically for the current CPU. It is highly"]
  #[doc = "              recommended to pass 0 here unless you know what you are doing."]
  #[doc = ""]
  #[doc = " @return 0 on success, a negative AVERROR on error."]
  pub fn av_frame_get_buffer(
    frame: *mut AVFrame,
    align: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Check if the frame data is writable."]
  #[doc = ""]
  #[doc = " @return A positive value if the frame data is writable (which is true if and"]
  #[doc = " only if each of the underlying buffers has only one reference, namely the one"]
  #[doc = " stored in this frame). Return 0 otherwise."]
  #[doc = ""]
  #[doc = " If 1 is returned the answer is valid until av_buffer_ref() is called on any"]
  #[doc = " of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly)."]
  #[doc = ""]
  #[doc = " @see av_frame_make_writable(), av_buffer_is_writable()"]
  pub fn av_frame_is_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Ensure that the frame data is writable, avoiding data copy if possible."]
  #[doc = ""]
  #[doc = " Do nothing if the frame is writable, allocate new buffers and copy the data"]
  #[doc = " if it is not."]
  #[doc = ""]
  #[doc = " @return 0 on success, a negative AVERROR on error."]
  #[doc = ""]
  #[doc = " @see av_frame_is_writable(), av_buffer_is_writable(),"]
  #[doc = " av_buffer_make_writable()"]
  pub fn av_frame_make_writable(frame: *mut AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Copy the frame data from src to dst."]
  #[doc = ""]
  #[doc = " This function does not allocate anything, dst must be already initialized and"]
  #[doc = " allocated with the same parameters as src."]
  #[doc = ""]
  #[doc = " This function only copies the frame data (i.e. the contents of the data /"]
  #[doc = " extended data arrays), not any other properties."]
  #[doc = ""]
  #[doc = " @return >= 0 on success, a negative AVERROR on error."]
  pub fn av_frame_copy(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Copy only \"metadata\" fields from src to dst."]
  #[doc = ""]
  #[doc = " Metadata for the purpose of this function are those fields that do not affect"]
  #[doc = " the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample"]
  #[doc = " aspect ratio (for video), but not width/height or channel layout."]
  #[doc = " Side data is also copied."]
  pub fn av_frame_copy_props(dst: *mut AVFrame, src: *const AVFrame) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Get the buffer reference a given data plane is stored in."]
  #[doc = ""]
  #[doc = " @param plane index of the data plane of interest in frame->extended_data."]
  #[doc = ""]
  #[doc = " @return the buffer reference that contains the plane or NULL if the input"]
  #[doc = " frame is not valid."]
  pub fn av_frame_get_plane_buffer(
    frame: *mut AVFrame,
    plane: ::std::os::raw::c_int,
  ) -> *mut AVBufferRef;
}
extern "C" {
  #[doc = " Add a new side data to a frame."]
  #[doc = ""]
  #[doc = " @param frame a frame to which the side data should be added"]
  #[doc = " @param type type of the added side data"]
  #[doc = " @param size size of the side data"]
  #[doc = ""]
  #[doc = " @return newly added side data on success, NULL on error"]
  pub fn av_frame_new_side_data(
    frame: *mut AVFrame,
    type_: AVFrameSideDataType,
    size: ::std::os::raw::c_int,
  ) -> *mut AVFrameSideData;
}
extern "C" {
  #[doc = " Add a new side data to a frame from an existing AVBufferRef"]
  #[doc = ""]
  #[doc = " @param frame a frame to which the side data should be added"]
  #[doc = " @param type  the type of the added side data"]
  #[doc = " @param buf   an AVBufferRef to add as side data. The ownership of"]
  #[doc = "              the reference is transferred to the frame."]
  #[doc = ""]
  #[doc = " @return newly added side data on success, NULL on error. On failure"]
  #[doc = "         the frame is unchanged and the AVBufferRef remains owned by"]
  #[doc = "         the caller."]
  pub fn av_frame_new_side_data_from_buf(
    frame: *mut AVFrame,
    type_: AVFrameSideDataType,
    buf: *mut AVBufferRef,
  ) -> *mut AVFrameSideData;
}
extern "C" {
  #[doc = " @return a pointer to the side data of a given type on success, NULL if there"]
  #[doc = " is no side data with such type in this frame."]
  pub fn av_frame_get_side_data(
    frame: *const AVFrame,
    type_: AVFrameSideDataType,
  ) -> *mut AVFrameSideData;
}
extern "C" {
  #[doc = " Remove and free all side data instances of the given type."]
  pub fn av_frame_remove_side_data(frame: *mut AVFrame, type_: AVFrameSideDataType);
}
#[doc = " Apply the maximum possible cropping, even if it requires setting the"]
#[doc = " AVFrame.data[] entries to unaligned pointers. Passing unaligned data"]
#[doc = " to FFmpeg API is generally not allowed, and causes undefined behavior"]
#[doc = " (such as crashes). You can pass unaligned data only to FFmpeg APIs that"]
#[doc = " are explicitly documented to accept it. Use this flag only if you"]
#[doc = " absolutely know what you are doing."]
pub const AV_FRAME_CROP_UNALIGNED: ::std::os::raw::c_uint = 1;
#[doc = " Flags for frame cropping."]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
  #[doc = " Crop the given video AVFrame according to its crop_left/crop_top/crop_right/"]
  #[doc = " crop_bottom fields. If cropping is successful, the function will adjust the"]
  #[doc = " data pointers and the width/height fields, and set the crop fields to 0."]
  #[doc = ""]
  #[doc = " In all cases, the cropping boundaries will be rounded to the inherent"]
  #[doc = " alignment of the pixel format. In some cases, such as for opaque hwaccel"]
  #[doc = " formats, the left/top cropping is ignored. The crop fields are set to 0 even"]
  #[doc = " if the cropping was rounded or ignored."]
  #[doc = ""]
  #[doc = " @param frame the frame which should be cropped"]
  #[doc = " @param flags Some combination of AV_FRAME_CROP_* flags, or 0."]
  #[doc = ""]
  #[doc = " @return >= 0 on success, a negative AVERROR on error. If the cropping fields"]
  #[doc = " were invalid, AVERROR(ERANGE) is returned, and nothing is changed."]
  pub fn av_frame_apply_cropping(
    frame: *mut AVFrame,
    flags: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " @return a string identifying the side data type"]
  pub fn av_frame_side_data_name(type_: AVFrameSideDataType) -> *const ::std::os::raw::c_char;
}
pub const SwrDitherType_SWR_DITHER_NONE: SwrDitherType = 0;
pub const SwrDitherType_SWR_DITHER_RECTANGULAR: SwrDitherType = 1;
pub const SwrDitherType_SWR_DITHER_TRIANGULAR: SwrDitherType = 2;
pub const SwrDitherType_SWR_DITHER_TRIANGULAR_HIGHPASS: SwrDitherType = 3;
#[doc = "< not part of API/ABI"]
pub const SwrDitherType_SWR_DITHER_NS: SwrDitherType = 64;
pub const SwrDitherType_SWR_DITHER_NS_LIPSHITZ: SwrDitherType = 65;
pub const SwrDitherType_SWR_DITHER_NS_F_WEIGHTED: SwrDitherType = 66;
pub const SwrDitherType_SWR_DITHER_NS_MODIFIED_E_WEIGHTED: SwrDitherType = 67;
pub const SwrDitherType_SWR_DITHER_NS_IMPROVED_E_WEIGHTED: SwrDitherType = 68;
pub const SwrDitherType_SWR_DITHER_NS_SHIBATA: SwrDitherType = 69;
pub const SwrDitherType_SWR_DITHER_NS_LOW_SHIBATA: SwrDitherType = 70;
pub const SwrDitherType_SWR_DITHER_NS_HIGH_SHIBATA: SwrDitherType = 71;
#[doc = "< not part of API/ABI"]
pub const SwrDitherType_SWR_DITHER_NB: SwrDitherType = 72;
#[doc = " Dithering algorithms"]
pub type SwrDitherType = ::std::os::raw::c_uint;
#[doc = "< SW Resampler"]
pub const SwrEngine_SWR_ENGINE_SWR: SwrEngine = 0;
#[doc = "< SoX Resampler"]
pub const SwrEngine_SWR_ENGINE_SOXR: SwrEngine = 1;
#[doc = "< not part of API/ABI"]
pub const SwrEngine_SWR_ENGINE_NB: SwrEngine = 2;
#[doc = " Resampling Engines"]
pub type SwrEngine = ::std::os::raw::c_uint;
#[doc = "< Cubic"]
pub const SwrFilterType_SWR_FILTER_TYPE_CUBIC: SwrFilterType = 0;
#[doc = "< Blackman Nuttall windowed sinc"]
pub const SwrFilterType_SWR_FILTER_TYPE_BLACKMAN_NUTTALL: SwrFilterType = 1;
#[doc = "< Kaiser windowed sinc"]
pub const SwrFilterType_SWR_FILTER_TYPE_KAISER: SwrFilterType = 2;
#[doc = " Resampling Filter Types"]
pub type SwrFilterType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwrContext {
  _unused: [u8; 0],
}
extern "C" {
  #[doc = " Get the AVClass for SwrContext. It can be used in combination with"]
  #[doc = " AV_OPT_SEARCH_FAKE_OBJ for examining options."]
  #[doc = ""]
  #[doc = " @see av_opt_find()."]
  #[doc = " @return the AVClass of SwrContext"]
  pub fn swr_get_class() -> *const AVClass;
}
extern "C" {
  #[doc = " Allocate SwrContext."]
  #[doc = ""]
  #[doc = " If you use this function you will need to set the parameters (manually or"]
  #[doc = " with swr_alloc_set_opts()) before calling swr_init()."]
  #[doc = ""]
  #[doc = " @see swr_alloc_set_opts(), swr_init(), swr_free()"]
  #[doc = " @return NULL on error, allocated context otherwise"]
  pub fn swr_alloc() -> *mut SwrContext;
}
extern "C" {
  #[doc = " Initialize context after user parameters have been set."]
  #[doc = " @note The context must be configured using the AVOption API."]
  #[doc = ""]
  #[doc = " @see av_opt_set_int()"]
  #[doc = " @see av_opt_set_dict()"]
  #[doc = ""]
  #[doc = " @param[in,out]   s Swr context to initialize"]
  #[doc = " @return AVERROR error code in case of failure."]
  pub fn swr_init(s: *mut SwrContext) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Check whether an swr context has been initialized or not."]
  #[doc = ""]
  #[doc = " @param[in]       s Swr context to check"]
  #[doc = " @see swr_init()"]
  #[doc = " @return positive if it has been initialized, 0 if not initialized"]
  pub fn swr_is_initialized(s: *mut SwrContext) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Allocate SwrContext if needed and set/reset common parameters."]
  #[doc = ""]
  #[doc = " This function does not require s to be allocated with swr_alloc(). On the"]
  #[doc = " other hand, swr_alloc() can use swr_alloc_set_opts() to set the parameters"]
  #[doc = " on the allocated context."]
  #[doc = ""]
  #[doc = " @param s               existing Swr context if available, or NULL if not"]
  #[doc = " @param out_ch_layout   output channel layout (AV_CH_LAYOUT_*)"]
  #[doc = " @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*)."]
  #[doc = " @param out_sample_rate output sample rate (frequency in Hz)"]
  #[doc = " @param in_ch_layout    input channel layout (AV_CH_LAYOUT_*)"]
  #[doc = " @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*)."]
  #[doc = " @param in_sample_rate  input sample rate (frequency in Hz)"]
  #[doc = " @param log_offset      logging level offset"]
  #[doc = " @param log_ctx         parent logging context, can be NULL"]
  #[doc = ""]
  #[doc = " @see swr_init(), swr_free()"]
  #[doc = " @return NULL on error, allocated context otherwise"]
  pub fn swr_alloc_set_opts(
    s: *mut SwrContext,
    out_ch_layout: i64,
    out_sample_fmt: AVSampleFormat,
    out_sample_rate: ::std::os::raw::c_int,
    in_ch_layout: i64,
    in_sample_fmt: AVSampleFormat,
    in_sample_rate: ::std::os::raw::c_int,
    log_offset: ::std::os::raw::c_int,
    log_ctx: *mut ::std::os::raw::c_void,
  ) -> *mut SwrContext;
}
extern "C" {
  #[doc = " Free the given SwrContext and set the pointer to NULL."]
  #[doc = ""]
  #[doc = " @param[in] s a pointer to a pointer to Swr context"]
  pub fn swr_free(s: *mut *mut SwrContext);
}
extern "C" {
  #[doc = " Closes the context so that swr_is_initialized() returns 0."]
  #[doc = ""]
  #[doc = " The context can be brought back to life by running swr_init(),"]
  #[doc = " swr_init() can also be used without swr_close()."]
  #[doc = " This function is mainly provided for simplifying the usecase"]
  #[doc = " where one tries to support libavresample and libswresample."]
  #[doc = ""]
  #[doc = " @param[in,out] s Swr context to be closed"]
  pub fn swr_close(s: *mut SwrContext);
}
extern "C" {
  #[doc = " Convert audio."]
  #[doc = ""]
  #[doc = " in and in_count can be set to 0 to flush the last few samples out at the"]
  #[doc = " end."]
  #[doc = ""]
  #[doc = " If more input is provided than output space, then the input will be buffered."]
  #[doc = " You can avoid this buffering by using swr_get_out_samples() to retrieve an"]
  #[doc = " upper bound on the required number of output samples for the given number of"]
  #[doc = " input samples. Conversion will run directly without copying whenever possible."]
  #[doc = ""]
  #[doc = " @param s         allocated Swr context, with parameters set"]
  #[doc = " @param out       output buffers, only the first one need be set in case of packed audio"]
  #[doc = " @param out_count amount of space available for output in samples per channel"]
  #[doc = " @param in        input buffers, only the first one need to be set in case of packed audio"]
  #[doc = " @param in_count  number of input samples available in one channel"]
  #[doc = ""]
  #[doc = " @return number of samples output per channel, negative value on error"]
  pub fn swr_convert(
    s: *mut SwrContext,
    out: *mut *mut u8,
    out_count: ::std::os::raw::c_int,
    in_: *mut *const u8,
    in_count: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Convert the next timestamp from input to output"]
  #[doc = " timestamps are in 1/(in_sample_rate * out_sample_rate) units."]
  #[doc = ""]
  #[doc = " @note There are 2 slightly differently behaving modes."]
  #[doc = "       @li When automatic timestamp compensation is not used, (min_compensation >= FLT_MAX)"]
  #[doc = "              in this case timestamps will be passed through with delays compensated"]
  #[doc = "       @li When automatic timestamp compensation is used, (min_compensation < FLT_MAX)"]
  #[doc = "              in this case the output timestamps will match output sample numbers."]
  #[doc = "              See ffmpeg-resampler(1) for the two modes of compensation."]
  #[doc = ""]
  #[doc = " @param s[in]     initialized Swr context"]
  #[doc = " @param pts[in]   timestamp for the next input sample, INT64_MIN if unknown"]
  #[doc = " @see swr_set_compensation(), swr_drop_output(), and swr_inject_silence() are"]
  #[doc = "      function used internally for timestamp compensation."]
  #[doc = " @return the output timestamp for the next output sample"]
  pub fn swr_next_pts(s: *mut SwrContext, pts: i64) -> i64;
}
extern "C" {
  #[doc = " Activate resampling compensation (\"soft\" compensation). This function is"]
  #[doc = " internally called when needed in swr_next_pts()."]
  #[doc = ""]
  #[doc = " @param[in,out] s             allocated Swr context. If it is not initialized,"]
  #[doc = "                              or SWR_FLAG_RESAMPLE is not set, swr_init() is"]
  #[doc = "                              called with the flag set."]
  #[doc = " @param[in]     sample_delta  delta in PTS per sample"]
  #[doc = " @param[in]     compensation_distance number of samples to compensate for"]
  #[doc = " @return    >= 0 on success, AVERROR error codes if:"]
  #[doc = "            @li @c s is NULL,"]
  #[doc = "            @li @c compensation_distance is less than 0,"]
  #[doc = "            @li @c compensation_distance is 0 but sample_delta is not,"]
  #[doc = "            @li compensation unsupported by resampler, or"]
  #[doc = "            @li swr_init() fails when called."]
  pub fn swr_set_compensation(
    s: *mut SwrContext,
    sample_delta: ::std::os::raw::c_int,
    compensation_distance: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Set a customized input channel mapping."]
  #[doc = ""]
  #[doc = " @param[in,out] s           allocated Swr context, not yet initialized"]
  #[doc = " @param[in]     channel_map customized input channel mapping (array of channel"]
  #[doc = "                            indexes, -1 for a muted channel)"]
  #[doc = " @return >= 0 on success, or AVERROR error code in case of failure."]
  pub fn swr_set_channel_mapping(
    s: *mut SwrContext,
    channel_map: *const ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Generate a channel mixing matrix."]
  #[doc = ""]
  #[doc = " This function is the one used internally by libswresample for building the"]
  #[doc = " default mixing matrix. It is made public just as a utility function for"]
  #[doc = " building custom matrices."]
  #[doc = ""]
  #[doc = " @param in_layout           input channel layout"]
  #[doc = " @param out_layout          output channel layout"]
  #[doc = " @param center_mix_level    mix level for the center channel"]
  #[doc = " @param surround_mix_level  mix level for the surround channel(s)"]
  #[doc = " @param lfe_mix_level       mix level for the low-frequency effects channel"]
  #[doc = " @param rematrix_maxval     if 1.0, coefficients will be normalized to prevent"]
  #[doc = "                            overflow. if INT_MAX, coefficients will not be"]
  #[doc = "                            normalized."]
  #[doc = " @param[out] matrix         mixing coefficients; matrix[i + stride * o] is"]
  #[doc = "                            the weight of input channel i in output channel o."]
  #[doc = " @param stride              distance between adjacent input channels in the"]
  #[doc = "                            matrix array"]
  #[doc = " @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)"]
  #[doc = " @param log_ctx             parent logging context, can be NULL"]
  #[doc = " @return                    0 on success, negative AVERROR code on failure"]
  pub fn swr_build_matrix(
    in_layout: u64,
    out_layout: u64,
    center_mix_level: f64,
    surround_mix_level: f64,
    lfe_mix_level: f64,
    rematrix_maxval: f64,
    rematrix_volume: f64,
    matrix: *mut f64,
    stride: ::std::os::raw::c_int,
    matrix_encoding: AVMatrixEncoding,
    log_ctx: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Set a customized remix matrix."]
  #[doc = ""]
  #[doc = " @param s       allocated Swr context, not yet initialized"]
  #[doc = " @param matrix  remix coefficients; matrix[i + stride * o] is"]
  #[doc = "                the weight of input channel i in output channel o"]
  #[doc = " @param stride  offset between lines of the matrix"]
  #[doc = " @return  >= 0 on success, or AVERROR error code in case of failure."]
  pub fn swr_set_matrix(
    s: *mut SwrContext,
    matrix: *const f64,
    stride: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Drops the specified number of output samples."]
  #[doc = ""]
  #[doc = " This function, along with swr_inject_silence(), is called by swr_next_pts()"]
  #[doc = " if needed for \"hard\" compensation."]
  #[doc = ""]
  #[doc = " @param s     allocated Swr context"]
  #[doc = " @param count number of samples to be dropped"]
  #[doc = ""]
  #[doc = " @return >= 0 on success, or a negative AVERROR code on failure"]
  pub fn swr_drop_output(s: *mut SwrContext, count: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Injects the specified number of silence samples."]
  #[doc = ""]
  #[doc = " This function, along with swr_drop_output(), is called by swr_next_pts()"]
  #[doc = " if needed for \"hard\" compensation."]
  #[doc = ""]
  #[doc = " @param s     allocated Swr context"]
  #[doc = " @param count number of samples to be dropped"]
  #[doc = ""]
  #[doc = " @return >= 0 on success, or a negative AVERROR code on failure"]
  pub fn swr_inject_silence(
    s: *mut SwrContext,
    count: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Gets the delay the next input sample will experience relative to the next output sample."]
  #[doc = ""]
  #[doc = " Swresample can buffer data if more input has been provided than available"]
  #[doc = " output space, also converting between sample rates needs a delay."]
  #[doc = " This function returns the sum of all such delays."]
  #[doc = " The exact delay is not necessarily an integer value in either input or"]
  #[doc = " output sample rate. Especially when downsampling by a large value, the"]
  #[doc = " output sample rate may be a poor choice to represent the delay, similarly"]
  #[doc = " for upsampling and the input sample rate."]
  #[doc = ""]
  #[doc = " @param s     swr context"]
  #[doc = " @param base  timebase in which the returned delay will be:"]
  #[doc = "              @li if it's set to 1 the returned delay is in seconds"]
  #[doc = "              @li if it's set to 1000 the returned delay is in milliseconds"]
  #[doc = "              @li if it's set to the input sample rate then the returned"]
  #[doc = "                  delay is in input samples"]
  #[doc = "              @li if it's set to the output sample rate then the returned"]
  #[doc = "                  delay is in output samples"]
  #[doc = "              @li if it's the least common multiple of in_sample_rate and"]
  #[doc = "                  out_sample_rate then an exact rounding-free delay will be"]
  #[doc = "                  returned"]
  #[doc = " @returns     the delay in 1 / @c base units."]
  pub fn swr_get_delay(s: *mut SwrContext, base: i64) -> i64;
}
extern "C" {
  #[doc = " Find an upper bound on the number of samples that the next swr_convert"]
  #[doc = " call will output, if called with in_samples of input samples. This"]
  #[doc = " depends on the internal state, and anything changing the internal state"]
  #[doc = " (like further swr_convert() calls) will may change the number of samples"]
  #[doc = " swr_get_out_samples() returns for the same number of input samples."]
  #[doc = ""]
  #[doc = " @param in_samples    number of input samples."]
  #[doc = " @note any call to swr_inject_silence(), swr_convert(), swr_next_pts()"]
  #[doc = "       or swr_set_compensation() invalidates this limit"]
  #[doc = " @note it is recommended to pass the correct available buffer size"]
  #[doc = "       to all functions like swr_convert() even if swr_get_out_samples()"]
  #[doc = "       indicates that less would be used."]
  #[doc = " @returns an upper bound on the number of samples that the next swr_convert"]
  #[doc = "          will output or a negative value to indicate an error"]
  pub fn swr_get_out_samples(
    s: *mut SwrContext,
    in_samples: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Return the @ref LIBSWRESAMPLE_VERSION_INT constant."]
  #[doc = ""]
  #[doc = " This is useful to check if the build-time libswresample has the same version"]
  #[doc = " as the run-time one."]
  #[doc = ""]
  #[doc = " @returns     the unsigned int-typed version"]
  pub fn swresample_version() -> ::std::os::raw::c_uint;
}
extern "C" {
  #[doc = " Return the swr build-time configuration."]
  #[doc = ""]
  #[doc = " @returns     the build-time @c ./configure flags"]
  pub fn swresample_configuration() -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Return the swr license."]
  #[doc = ""]
  #[doc = " @returns     the license of libswresample, determined at build-time"]
  pub fn swresample_license() -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Convert the samples in the input AVFrame and write them to the output AVFrame."]
  #[doc = ""]
  #[doc = " Input and output AVFrames must have channel_layout, sample_rate and format set."]
  #[doc = ""]
  #[doc = " If the output AVFrame does not have the data pointers allocated the nb_samples"]
  #[doc = " field will be set using av_frame_get_buffer()"]
  #[doc = " is called to allocate the frame."]
  #[doc = ""]
  #[doc = " The output AVFrame can be NULL or have fewer allocated samples than required."]
  #[doc = " In this case, any remaining samples not written to the output will be added"]
  #[doc = " to an internal FIFO buffer, to be returned at the next call to this function"]
  #[doc = " or to swr_convert()."]
  #[doc = ""]
  #[doc = " If converting sample rate, there may be data remaining in the internal"]
  #[doc = " resampling delay buffer. swr_get_delay() tells the number of"]
  #[doc = " remaining samples. To get this data as output, call this function or"]
  #[doc = " swr_convert() with NULL input."]
  #[doc = ""]
  #[doc = " If the SwrContext configuration does not match the output and"]
  #[doc = " input AVFrame settings the conversion does not take place and depending on"]
  #[doc = " which AVFrame is not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED"]
  #[doc = " or the result of a bitwise-OR of them is returned."]
  #[doc = ""]
  #[doc = " @see swr_delay()"]
  #[doc = " @see swr_convert()"]
  #[doc = " @see swr_get_delay()"]
  #[doc = ""]
  #[doc = " @param swr             audio resample context"]
  #[doc = " @param output          output AVFrame"]
  #[doc = " @param input           input AVFrame"]
  #[doc = " @return                0 on success, AVERROR on failure or nonmatching"]
  #[doc = "                        configuration."]
  pub fn swr_convert_frame(
    swr: *mut SwrContext,
    output: *mut AVFrame,
    input: *const AVFrame,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[doc = " Configure or reconfigure the SwrContext using the information"]
  #[doc = " provided by the AVFrames."]
  #[doc = ""]
  #[doc = " The original resampling context is reset even on failure."]
  #[doc = " The function calls swr_close() internally if the context is open."]
  #[doc = ""]
  #[doc = " @see swr_close();"]
  #[doc = ""]
  #[doc = " @param swr             audio resample context"]
  #[doc = " @param output          output AVFrame"]
  #[doc = " @param input           input AVFrame"]
  #[doc = " @return                0 on success, AVERROR on failure."]
  pub fn swr_config_frame(
    swr: *mut SwrContext,
    out: *const AVFrame,
    in_: *const AVFrame,
  ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
  pub gp_offset: ::std::os::raw::c_uint,
  pub fp_offset: ::std::os::raw::c_uint,
  pub overflow_arg_area: *mut ::std::os::raw::c_void,
  pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
  assert_eq!(
    ::std::mem::size_of::<__va_list_tag>(),
    24usize,
    concat!("Size of: ", stringify!(__va_list_tag))
  );
  assert_eq!(
    ::std::mem::align_of::<__va_list_tag>(),
    8usize,
    concat!("Alignment of ", stringify!(__va_list_tag))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(gp_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(fp_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(overflow_arg_area)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(reg_save_area)
    )
  );
}
#[doc = " a pointer to the first option specified in the class if any or NULL"]
#[doc = ""]
#[doc = " @see av_set_default_options()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOption {
  pub _address: u8,
}
